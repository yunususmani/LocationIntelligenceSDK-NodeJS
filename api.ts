/**
 * Location Intelligence APIs
 * Incorporate our extensive geodata into everyday applications, business processes and workflows.
 *
 * OpenAPI spec version: 6.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import request = require('request');
import http = require('http');
import moment = require('moment');


import Promise = require('bluebird');

let defaultBasePath = 'https://api.pitneybowes.com/location-intelligence';



// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */

export class oAuthCredInfo {
"access_token": string;
"tokenType": string;
"issuedAt": number;
"expiresIn": number;
"clientID": string;
"org": string;
}

export class AHJ {
    'ahjType': string;
    'ahjId': string;
    'agency': string;
    'phone': string;
    'comments': string;
    'coverage': Coverage;
    'contactPerson': ContactPerson;
    'mailingAddress': AHJmailingAddress;
}

export class AHJList {
    'ahjs': Array<AHJ>;
}

export class AHJPlusPSAPResponse {
    'ahjs': AHJList;
    'psap': PSAPResponse;
    'count': number;
}

export class AHJmailingAddress {
    'formattedAddress': string;
    'mainAddressLine': string;
    'addressLastLine': string;
    'placeName': string;
    'areaName1': string;
    'areaName2': string;
    'areaName3': string;
    'areaName4': string;
    'postCode': string;
    'postCodeExt': string;
    'country': string;
    'addressNumber': string;
    'streetName': string;
    'unitType': string;
    'unitValue': string;
}

export class Accuracy {
    'unit': string;
    'value': string;
}

export class Address {
    'objectId': string;
    'displayName': string;
    'streetSide': string;
    'businessName': string;
    'addressLine1': string;
    'addressLine2': string;
    'addressLine3': string;
    'city': string;
    'stateProvince': string;
    'county': string;
    'postalCode': string;
    'latitude': string;
    'longitude': string;
    'status': string;
    'urbanizationName': string;
    'formattedAddress': string;
    'mainAddressLine': string;
    'addressLastLine': string;
    'placeName': string;
    'areaName1': string;
    'areaName2': string;
    'areaName3': string;
    'areaName4': string;
    'postCode': string;
    'postCodeExt': string;
    'country': string;
    'addressNumber': string;
    'streetName': string;
    'unitType': string;
    'unitValue': string;
}

export class AddressBylocation {
    'match': Match;
    'address': MatchedAddress;
    'distance': Distance;
    'geometry': Geometry;
}

export class Age {
    'birthday': Birthday;
    'range': string;
    'value': number;
}

export class AgeTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariable>;
    'rangeVariable': Array<RangeVariable>;
}

export class Area {
    'unit': string;
    'value': string;
}

export class AreaCodeInfo {
    'companyName': string;
    'ocn': string;
    'ocnCategory': string;
    'npa': string;
    'nxx': string;
    'startRange': string;
    'endRange': string;
    'lata': string;
    'areaName4': string;
}

export class AssetsAndWealthTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariableV2>;
    'rangeVariable': Array<RangeVariableV2>;
}

export class AttitudesAndMotivationTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariable>;
    'rangeVariable': Array<RangeVariable>;
}

export class AutomobileTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariable>;
    'rangeVariable': Array<RangeVariable>;
}

export class BaseFloodElevation {
    'unit': string;
    'value': string;
}

export class BasicBoundary {
    'center': BoundaryPoint;
    'geometry': PolygonGeometry;
    'distance': Distance;
}

export class BasicBoundaryAddress {
    'center': BoundaryPoint;
    'geometry': PolygonGeometry;
    'matchedAddress': MatchedAddress;
    'distance': Distance;
}

export class Birthday {
    'year': number;
    'month': number;
    'day': number;
}

export class Boundaries {
    'boundary': Array<Boundary>;
}

export class Boundary {
    'boundaryId': string;
    'boundaryType': string;
    'boundaryRef': string;
}

export class BoundaryBuffer {
    'bufferRelation': BufferRelation;
    'distanceToBorder': DistanceToBorder;
}

export class BoundaryPoint {
    'type': string;
    'coordinates': Array<number>;
}

export class BufferRelation {
    'description': string;
    'value': string;
}

export class Candidate {
    'precisionLevel': number;
    'formattedStreetAddress': string;
    'formattedLocationAddress': string;
    'identifier': string;
    'precisionCode': string;
    'sourceDictionary': string;
    'matching': FieldsMatching;
    'geometry': GeoPos;
    'address': GeocodeAddress;
    'ranges': Array<CandidateRange>;
}

export class CandidateRange {
    'placeName': string;
    'lowHouse': string;
    'highHouse': string;
    'side': CandidateRange.SideEnum;
    'oddEvenIndicator': CandidateRange.OddEvenIndicatorEnum;
    'units': Array<CandidateRangeUnit>;
    'customValues': { [key: string]: any; };
}

export namespace CandidateRange {
    export enum SideEnum {
        UNKNOWN = <any> 'UNKNOWN',
        LEFT = <any> 'LEFT',
        RIGHT = <any> 'RIGHT',
        BOTH = <any> 'BOTH'
    }
    export enum OddEvenIndicatorEnum {
        UNKNOWN = <any> 'UNKNOWN',
        BOTH = <any> 'BOTH',
        ODD = <any> 'ODD',
        EVEN = <any> 'EVEN',
        IRREGULAR = <any> 'IRREGULAR'
    }
}
export class CandidateRangeUnit {
    'placeName': string;
    'unitType': string;
    'highUnitValue': string;
    'lowUnitValue': string;
    'customValues': { [key: string]: any; };
}

export class Carrier {
    'asn': string;
    'value': string;
}

export class CarrierRouteAddressRequest {
    'addresses': Array<CommonAddress>;
    'preferences': CarrierRoutePreference;
}

export class CarrierRouteBoundaries {
    'boundary': Array<RouteBoundary>;
}

export class CarrierRoutePreference {
    'includeGeometry': string;
    'postCode': string;
}

export class CarrierRouteResponse {
    'objectId': string;
    'matchedAddress': MatchedAddress;
    'code': string;
    'state': CommonState;
    'countyFips': string;
    'postalTown': string;
    'postCode': string;
    'routeDelivery': RouteDelivery;
    'boundary': RouteBoundary;
    'boundaryRef': string;
}

export class CarrierRouteResponseList {
    'boundaries': CarrierRouteBoundaries;
    'carrierRoute': Array<CarrierRouteResponse>;
}

export class Cbsa {
    'name': string;
    'code': string;
}

export class Census {
    'cbsa': Cbsa;
    'matchLevel': string;
    'matchCode': string;
    'tract': string;
    'mcd': Mcd;
}

export class ChannelPreferencesTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariable>;
    'rangeVariable': Array<RangeVariable>;
}

export class City {
    'confidence': string;
    'value': string;
}

export class CommonAddress {
    'objectId': string;
    'mainAddressLine': string;
    'addressLastLine': string;
    'placeName': string;
    'areaName1': string;
    'areaName2': string;
    'areaName3': string;
    'areaName4': string;
    'postCode': string;
    'postCodeExt': string;
    'country': string;
    'addressNumber': string;
    'streetName': string;
    'unitType': string;
    'unitValue': string;
}

export class CommonState {
    'fips': string;
    'code': string;
}

export class Community {
    'number': string;
    'status': Status;
}

export class CommuterPatternsTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariable>;
    'rangeVariable': Array<RangeVariable>;
}

export class ConfiguredDictionaryResponse {
    'dictionaries': Array<Dictionary>;
}

export class ContactDetails {
    'address': MatchedAddress;
    'phone': string;
    'fax': string;
    'email': string;
    'url': string;
}

export class ContactPerson {
    'title': string;
    'prefix': string;
    'firstName': string;
    'lastName': string;
    'phone': string;
    'fax': string;
    'email': string;
    'comments': string;
    'additionalDetails': string;
}

export class Cost {
    'cost': number;
    'costUnit': string;
    'geometry': DirectionGeometry;
}

export class Costs extends Array<Cost> {
}

export class CountrySupport {
    'supportedCountries': Array<string>;
    'supportedDataTypes': Array<string>;
}

export class County {
    'name': string;
    'fips': string;
}

export class Coverage {
    'area': string;
    'comments': string;
    'exceptions': string;
}

export class CrimeBoundary {
    'id': string;
    'type': string;
    'ref': string;
    'geometry': GeoRiskGeometry;
}

export class CrimeIndexTheme {
    'source': string;
    'boundaryRef': string;
    'indexVariable': Array<IndexVariable>;
}

export class CrimeRiskByAddressRequest {
    'addresses': Array<RiskAddress>;
    'preferences': CrimeRiskPreferences;
}

export class CrimeRiskByLocationRequest {
    'locations': Array<GeoRiskLocations>;
    'preferences': CrimeRiskPreferences;
}

export class CrimeRiskLocationResponse {
    'themes': Array<GeoRiskCrimeTheme>;
    'boundaries': GeoRiskBoundaries;
}

export class CrimeRiskLocationResponseList {
    'crimeRisk': Array<CrimeRiskLocationResponse>;
}

export class CrimeRiskPreferences {
    'includeGeometry': string;
    'type': string;
}

export class CrimeRiskResponse {
    'themes': Array<GeoRiskCrimeTheme>;
    'boundaries': GeoRiskBoundaries;
    'matchedAddress': MatchedAddress;
}

export class CrimeRiskResponseList {
    'crimeRisk': Array<CrimeRiskResponse>;
}

export class Crs {
    'type': string;
    'properties': Properties;
}

export class CustomObject {
    'name': string;
    'description': string;
    'properties': Array<CustomObjectMember>;
}

export class CustomObjectMember {
    'name': string;
    'input': InputParameter;
    'output': OutputParameter;
}

export class CustomPreferences {
    'fINDADDRPOINTINTERP': boolean;
    'fINDSEARCHAREA': string;
    'fINDADDRESSRANGE': boolean;
    'fINDEXPANDEDSEARCHRADIUS': string;
    'fINDALTERNATELOOKUP': string;
    'fINDSTREETCENTROID': boolean;
    'fINDFIRSTLETTEREXPANDED': boolean;
}

export class DateTimeEarthQuake {
    'date': string;
    'time': string;
}

export class Demographics {
    'boundaries': Boundaries;
    'themes': DemographicsThemes;
}

export class DemographicsThemes {
    'ageTheme': AgeTheme;
    'genderTheme': GenderTheme;
    'incomeTheme': IncomeTheme;
    'raceTheme': RaceTheme;
    'ethnicityTheme': EthnicityTheme;
    'maritalStatusTheme': MaritalStatusTheme;
    'automobileTheme': AutomobileTheme;
    'purchasingBehaviorTheme': PurchasingBehaviorTheme;
    'educationalAttainmentTheme': EducationalAttainmentTheme;
    'financialProductsTheme': FinancialProductsTheme;
    'commuterPatternsTheme': CommuterPatternsTheme;
    'attitudesAndMotivationTheme': AttitudesAndMotivationTheme;
    'channelPreferencesTheme': ChannelPreferencesTheme;
    'householdSizeTheme': HouseholdSizeTheme;
}

export class DemographicsThemesV2 {
    'populationTheme': PopulationTheme;
    'raceAndEthnicityTheme': RaceAndEthnicityTheme;
    'healthTheme': HealthTheme;
    'educationTheme': EducationTheme;
    'incomeTheme': IncomeThemeV2;
    'assetsAndWealthTheme': AssetsAndWealthTheme;
    'householdsTheme': HouseholdsTheme;
    'housingTheme': HousingTheme;
    'employmentTheme': EmploymentTheme;
    'expenditureTheme': ExpenditureTheme;
    'supplyAndDemandTheme': SupplyAndDemandTheme;
}

export class DemographicsV2 {
    'boundaries': Boundaries;
    'themes': DemographicsThemesV2;
}

export class Depth {
    'unit': string;
    'value': number;
}

export class DeviceStatusNetwork {
    'carrier': string;
    'callType': string;
    'locAccuracySupport': string;
    'nationalNumber': string;
    'country': GeoLocationFixedLineCountry;
}

export class Dictionary {
    'vintage': string;
    'source': string;
    'description': string;
    'countrySupportInfos': Array<CountrySupport>;
}

export class DirectionGeometry {
    'type': string;
    'coordinates': Array<Array<Array<Array<number>>>>;
}

export class Distance {
    'unit': string;
    'value': string;
}

export class DistanceToBorder {
    'unit': string;
    'value': string;
}

export class DistanceToFloodHazardAddressRequest {
    'addresses': Array<RiskAddress>;
    'preferences': FloodHazardPreferences;
}

export class DistanceToFloodHazardLocationRequest {
    'locations': Array<GeoRiskLocations>;
    'preferences': FloodHazardPreferences;
}

export class DistanceToFloodHazardLocationResponse {
    'waterBodies': Array<WaterBodyLocationResponse>;
}

export class DistanceToFloodHazardResponse {
    'waterBodies': Array<WaterBodyResponse>;
}

export class DistrictType {
    'description': string;
    'value': string;
}

export class EarthquakeEvent {
    'dateTime': DateTimeEarthQuake;
    'seismicRegionNumber': number;
    'depth': Depth;
    'magnitude': Magnitude;
    'cause': string;
    'culturalEffect': string;
    'intensity': number;
    'diastrophism': string;
    'miscPhenomena': string;
    'location': EarthquakeLocation;
}

export class EarthquakeEventsResponse {
    'event': Array<EarthquakeEvent>;
}

export class EarthquakeHistory {
    'stateCode': string;
    'county': string;
    'postCode': string;
    'events': EarthquakeEventsResponse;
}

export class EarthquakeLocation {
    'type': string;
    'coordinates': Array<number>;
}

export class EarthquakeRiskByAddressRequest {
    'addresses': Array<RiskAddress>;
    'preferences': EarthquakeRiskPreferences;
}

export class EarthquakeRiskByLocationRequest {
    'locations': Array<GeoRiskLocations>;
    'preferences': EarthquakeRiskPreferences;
}

export class EarthquakeRiskLocationResponse {
    'riskLevel': string;
    'eventsCount': EventsCount;
    'grid': Grid;
}

export class EarthquakeRiskLocationResponseList {
    'earthquakeRisk': Array<EarthquakeRiskLocationResponse>;
}

export class EarthquakeRiskPreferences {
    'includeGeometry': string;
    'richterValue': string;
}

export class EarthquakeRiskResponse {
    'riskLevel': string;
    'eventsCount': EventsCount;
    'grid': Grid;
    'matchedAddress': MatchedAddress;
}

export class EarthquakeRiskResponseList {
    'earthquakeRisk': Array<EarthquakeRiskResponse>;
}

export class Education {
    'name': string;
    'degree': string;
    'start': Start;
    'end': End;
}

export class EducationTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariableV2>;
    'rangeVariable': Array<RangeVariableV2>;
}

export class EducationalAttainmentTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariable>;
    'rangeVariable': Array<RangeVariable>;
}

export class Email {
    'label': string;
    'value': string;
    'md5': string;
    'sha256': string;
}

export class Employment {
    'name': string;
    'domain': string;
    'current': boolean;
    'title': string;
    'start': Start;
    'end': End;
}

export class EmploymentTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariableV2>;
    'rangeVariable': Array<RangeVariableV2>;
}

export class End {
    'year': number;
    'month': number;
    'day': number;
}

export class EthnicityTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariable>;
    'rangeVariable': Array<RangeVariable>;
}

export class EventsCount {
    'total': string;
    'r0': string;
    'r1': string;
    'r2': string;
    'r3': string;
    'r4': string;
    'r5': string;
    'r6': string;
    'r7': string;
    'r0Ge': string;
    'r1Ge': string;
    'r2Ge': string;
    'r3Ge': string;
    'r4Ge': string;
    'r5Ge': string;
    'r6Ge': string;
    'r7Ge': string;
}

export class ExpenditureTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariableV2>;
    'rangeVariable': Array<RangeVariableV2>;
}

export class Field {
    'value': string;
    'description': string;
}

export class FieldV2 {
    'value': string;
    'name': string;
    'description': string;
}

export class FieldsMatching {
    'matchOnAddressNumber': boolean;
    'matchOnPostCode1': boolean;
    'matchOnPostCode2': boolean;
    'matchOnAreaName1': boolean;
    'matchOnAreaName2': boolean;
    'matchOnAreaName3': boolean;
    'matchOnAreaName4': boolean;
    'matchOnAllStreetFields': boolean;
    'matchOnStreetName': boolean;
    'matchOnStreetType': boolean;
    'matchOnStreetDirectional': boolean;
    'matchOnPlaceName': boolean;
    'matchOnInputFields': boolean;
}

export class FinancialProductsTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariable>;
    'rangeVariable': Array<RangeVariable>;
}

export class FireDepartment {
    'name': string;
    'type': string;
    'numberOfStations': number;
    'administrativeOfficeOnly': boolean;
    'contactDetails': FireDepartmentContactDetails;
}

export class FireDepartmentContactDetails {
    'address': MatchedAddress;
    'phone': string;
    'fax': string;
}

export class FireEvent {
    'fireStartDate': string;
    'fireEndDate': string;
    'fireName': string;
    'area': Area;
    'agency': string;
}

export class FireEventsResponse {
    'event': Array<FireEvent>;
}

export class FireHistory {
    'stateCode': string;
    'postCode': string;
    'events': FireEventsResponse;
}

export class FireRiskByAddressRequest {
    'addresses': Array<RiskAddress>;
}

export class FireRiskByLocationRequest {
    'locations': Array<GeoRiskLocations>;
}

export class FireRiskLocationResponse {
    'objectId': string;
    'state': CommonState;
    'fireShed': FireShed;
}

export class FireRiskLocationResponseList {
    'fireRisk': Array<FireRiskLocationResponse>;
}

export class FireRiskResponse {
    'objectId': string;
    'state': CommonState;
    'fireShed': FireShed;
    'matchedAddress': MatchedAddress;
}

export class FireRiskResponseList {
    'fireRisk': Array<FireRiskResponse>;
}

export class FireShed {
    'id': number;
    'risk': Risk;
}

export class FireStation {
    'numWithinDepartment': string;
    'locationReference': string;
    'travelDistance': Distance;
    'travelTime': Time;
    'contactDetails': FireStationContactDetails;
    'fireDepartment': FireDepartment;
    'geometry': Geometry;
}

export class FireStationContactDetails {
    'address': MatchedAddress;
    'phone': string;
}

export class FireStations {
    'fireStation': Array<FireStation>;
    'matchedAddress': MatchedAddress;
}

export class FireStationsLocation {
    'fireStation': Array<FireStation>;
}

export class FloodBoundary {
    'id': string;
    'geometry': GeoRiskGeometry;
}

export class FloodHazardPreferences {
    'searchDistanceUnit': string;
    'searchDistance': string;
    'waterBodyType': string;
    'maxCandidates': string;
}

export class FloodRiskByAddressRequest {
    'addresses': Array<RiskAddress>;
    'preferences': FloodRiskPreferences;
}

export class FloodRiskByLocationRequest {
    'locations': Array<GeoRiskLocations>;
    'preferences': FloodRiskPreferences;
}

export class FloodRiskLocationResponse {
    'objectId': string;
    'state': CommonState;
    'floodZone': FloodZone;
    'community': Community;
    'boundary': FloodBoundary;
}

export class FloodRiskLocationResponseList {
    'floodRisk': Array<FloodRiskLocationResponse>;
}

export class FloodRiskPreferences {
    'includeGeometry': string;
    'includeZoneDesc': string;
}

export class FloodRiskResponse {
    'objectId': string;
    'state': CommonState;
    'floodZone': FloodZone;
    'community': Community;
    'boundary': FloodBoundary;
    'matchedAddress': MatchedAddress;
}

export class FloodRiskResponseList {
    'floodRisk': Array<FloodRiskResponse>;
}

export class FloodZone {
    'code': string;
    'areaType': string;
    'riskLevel': string;
    'primaryZone': PrimaryZone;
    'baseFloodElevation': BaseFloodElevation;
    'additionalInfo': string;
}

export class GenderTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariable>;
    'rangeVariable': Array<RangeVariable>;
}

export class GeoIdentityName {
    'given': string;
    'family': string;
    'middle': string;
    'prefix': string;
    'suffix': string;
    'nickname': string;
}

export class GeoIdentityPlace {
    'level': string;
    'name': string;
}

export class GeoIdentityResponse {
    'identities': Array<Identity>;
}

export class GeoLocationAccessPoint {
    'geometry': Geometry;
    'accuracy': Accuracy;
}

export class GeoLocationCountry {
    'code': string;
    'confidence': string;
    'value': string;
}

export class GeoLocationDeviceSatus {
    'deviceId': string;
    'locatable': string;
    'network': DeviceStatusNetwork;
    'privacyConsentRequired': string;
}

export class GeoLocationFixedLine {
    'geometry': Geometry;
    'accuracy': Accuracy;
    'deviceId': string;
    'country': GeoLocationFixedLineCountry;
}

export class GeoLocationFixedLineCountry {
    'code': string;
    'value': string;
}

export class GeoLocationIpAddr {
    'geometry': Geometry;
    'ipInfo': IpInfo;
}

export class GeoLocationPlace {
    'continent': string;
    'country': GeoLocationCountry;
    'region': string;
    'state': GeoLocationState;
    'city': City;
    'postCode': string;
}

export class GeoLocationState {
    'confidence': string;
    'value': string;
}

export class GeoPos {
    'type': string;
    'coordinates': Array<number>;
    'crs': Crs;
}

export class GeoPostGeometry {
    'type': string;
    'coordinates': Array<Array<Array<Array<number>>>>;
}

export class GeoPropertyAddressRequest {
    'addresses': Array<CommonAddress>;
}

export class GeoPropertyPBKeyRequest {
    'pbkeys': Array<PbKey>;
}

export class GeoPropertyPBKeyResponse {
    'objectId': string;
    'category': string;
    'individualValueVariable': Array<IndividualValueVariable>;
}

export class GeoPropertyPBKeyResponses {
    'propertyAttributes': Array<GeoPropertyPBKeyResponse>;
}

export class GeoPropertyResponse {
    'objectId': string;
    'category': string;
    'individualValueVariable': Array<IndividualValueVariable>;
    'matchedAddress': MatchedAddress;
}

export class GeoPropertyResponses {
    'propertyAttributes': Array<GeoPropertyResponse>;
}

export class GeoRiskBoundaries {
    'boundary': Array<CrimeBoundary>;
}

export class GeoRiskCrimeTheme {
    'crimeIndexTheme': CrimeIndexTheme;
}

export class GeoRiskGeometry {
    'type': string;
    'coordinates': Array<Array<Array<number>>>;
}

export class GeoRiskLocations {
    'geometry': Geometry;
    'objectId': string;
}

export class GeoRouteResponse {
    'directionsStyle': string;
    'distance': number;
    'distanceUnit': string;
    'language': string;
    'timeUnit': string;
    'time': number;
    'geometry': RouteGeometry;
    'routeDirections': RouteDirections;
}

export class GeoTaxLocations {
    'geometry': Geometry;
    'purchaseAmount': string;
    'objectId': string;
}

export class GeoTaxRateLocations {
    'geometry': Geometry;
    'objectId': string;
}

export class GeocodeAddress {
    'mainAddressLine': string;
    'addressLastLine': string;
    'placeName': string;
    'areaName1': string;
    'areaName2': string;
    'areaName3': string;
    'areaName4': string;
    'postCode1': string;
    'postCode2': string;
    'country': string;
    'addressNumber': string;
    'streetName': string;
    'unitType': string;
    'unitValue': string;
    'customFields': { [key: string]: any; };
}

export class GeocodeCapabilitiesResponse {
    'serviceName': string;
    'serviceDescription': string;
    'coreVersion': string;
    'supportedCountries': Array<string>;
    'supportedOperations': Array<Operation>;
    'customObjects': Array<CustomObject>;
}

export class GeocodeCustomPreferences {
    'fALLBACKTOWORLD': boolean;
    'uSEADDRESSPOINTINTERPOLATION': boolean;
    'uSECENTERLINEOFFSET': string;
    'cENTERLINEOFFSET': string;
}

export class GeocodePreferences {
    'returnAllCandidateInfo': boolean;
    'fallbackToGeographic': boolean;
    'fallbackToPostal': boolean;
    'maxReturnedCandidates': string;
    'streetOffset': string;
    'cornerOffset': string;
    'matchMode': string;
    'clientLocale': string;
    'clientCoordSysName': string;
    'streetOffsetUnits': string;
    'cornerOffsetUnits': string;
    'mustMatchFields': FieldsMatching;
    'returnFieldsDescriptor': ReturnFieldsDescriptor;
    'outputRecordType': string;
    'customPreferences': GeocodeCustomPreferences;
    'preferredDictionaryOrders': Array<string>;
}

export class GeocodeRequest {
    /**
    * Type
    */
    'type': string;
    'preferences': GeocodePreferences;
    'addresses': Array<GeocodeRequestAddress>;
}

export class GeocodeRequestAddress {
    'mainAddressLine': string;
    'addressLastLine': string;
    'placeName': string;
    'areaName1': string;
    'areaName2': string;
    'areaName3': string;
    'areaName4': string;
    'postCode1': string;
    'postCode2': string;
    'country': string;
    'addressNumber': string;
    'streetName': string;
    'unitType': string;
    'unitValue': string;
}

export class GeocodeServiceResponse {
    'objectId': string;
    'totalPossibleCandidates': number;
    'totalMatches': number;
    'candidates': Array<Candidate>;
}

export class GeocodeServiceResponseList {
    'responses': Array<GeocodeServiceResponse>;
}

export class Geometry {
    'type': string;
    'coordinates': Array<number>;
}

export class GeosearchLocation {
    'address': MatchedAddress;
    'distance': Distance;
    'geometry': Geometry;
}

export class GeosearchLocations {
    'location': Array<GeosearchLocation>;
}

export class Grid {
    'code': string;
    'geometry': GeoRiskGeometry;
}

export class HealthTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariableV2>;
    'rangeVariable': Array<RangeVariableV2>;
}

export class HouseholdFinance {
    'averageIncome': string;
    'averageAssets': string;
    'averageWealth': string;
    'boundary': Boundary;
}

export class HouseholdSizeTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariable>;
    'rangeVariable': Array<RangeVariable>;
}

export class HouseholdsTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariableV2>;
    'rangeVariable': Array<RangeVariableV2>;
}

export class HousingTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariableV2>;
    'rangeVariable': Array<RangeVariableV2>;
}

export class IPDTaxByAddressBatchRequest {
    'addresses': Array<TaxRateAddress>;
    'preferences': Preferences;
}

export class IPDTaxJurisdiction {
    'state': TaxState;
    'county': TaxCounty;
    'place': TaxPlace;
}

export class Identity {
    'email': string;
    'emailHash': string;
    'twitter': string;
    'phone': string;
    'fullName': string;
    'ageRange': string;
    'gender': string;
    'location': string;
    'title': string;
    'organization': string;
    'linkedin': string;
    'facebook': string;
    'bio': string;
    'avatar': string;
    'website': string;
    'details': IdentityDetail;
    'property': Property;
    'neighborhood': Neighborhood;
}

export class IdentityDetail {
    'interests': Array<Interest>;
    'profiles': { [key: string]: Profile; };
    'photos': Array<Photo>;
    'urls': Array<Url>;
    'name': GeoIdentityName;
    'age': Age;
    'gender': string;
    'locations': Array<Location>;
    'education': Array<Education>;
    'emails': Array<Email>;
    'employment': Array<Employment>;
    'topics': Array<Topic>;
}

export class IncomeTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariable>;
    'rangeVariable': Array<RangeVariable>;
}

export class IncomeThemeV2 {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariableV2>;
    'rangeVariable': Array<RangeVariableV2>;
}

export class IndexVariable {
    'name': string;
    'score': string;
    'category': string;
    'percentile': string;
}

export class IndividualValueVariable {
    'name': string;
    'description': string;
    'value': string;
}

export class IndividualValueVariableV2 {
    'name': string;
    'description': string;
    'year': string;
    'value': string;
}

export class InputParameter {
    'name': string;
    'description': string;
    'type': string;
    'defaultValue': string;
    'lowBoundary': string;
    'highBoundary': string;
    'allowedValuesWithDescriptions': { [key: string]: any; };
}

export class Interest {
    'name': string;
    'id': string;
    'affinity': string;
    'parentIds': Array<string>;
    'category': string;
}

export class IpInfo {
    'ipAddress': string;
    'proxy': Proxy;
    'network': Network;
    'place': GeoLocationPlace;
}

export class Ipd {
    'id': string;
    'districtName': string;
    'districtType': DistrictType;
    'taxCodeDescription': string;
    'effectiveDate': string;
    'expirationDate': string;
    'boundaryBuffer': BoundaryBuffer;
    'rates': Array<Rate>;
}

export class LatLongFields {
    'matchCode': string;
    'matchLevel': string;
    'streetMatchCode': string;
    'streetMatchLevel': string;
    'geometry': Geometry;
}

export class LifeStyleTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariable>;
    'rangeVariable': Array<RangeVariable>;
}

export class Lifestyle {
    'internationalType': string;
    'groupType': string;
    'categoryType': string;
    'boundary': Boundary;
}

export class Location {
    'label': string;
    'city': string;
    'region': string;
    'regionCode': string;
    'country': string;
    'countryCode': string;
    'formatted': string;
}

export class Locations {
    'location': Array<AddressBylocation>;
}

export class Magnitude {
    'value': number;
    'scale': string;
    'bodyWave': number;
    'surfaceWave': number;
}

export class MaritalStatusTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariable>;
    'rangeVariable': Array<RangeVariable>;
}

export class Match {
    'confidence': string;
    'percentGeocode': string;
    'precisionLevel': string;
    'locationCode': string;
    'matchCode': string;
}

export class MatchedAddress {
    'formattedAddress': string;
    'mainAddressLine': string;
    'addressLastLine': string;
    'placeName': string;
    'areaName1': string;
    'areaName2': string;
    'areaName3': string;
    'areaName4': string;
    'postCode': string;
    'postCodeExt': string;
    'country': string;
    'addressNumber': string;
    'streetName': string;
    'unitType': string;
    'unitValue': string;
}

export class Matrix {
    'distance': number;
    'distanceUnit': string;
    'endPoint': StartEndPoint;
    'startPoint': StartEndPoint;
    'time': number;
    'timeUnit': string;
}

export class Mcd {
    'name': string;
    'code': string;
}

export class Name {
    'langType': string;
    'langISOCode': string;
    'value': string;
}

export class Neighborhood {
    'place': GeoIdentityPlace;
    'lifestyle': Lifestyle;
    'householdFinance': HouseholdFinance;
}

export class Network {
    'connectionFromHome': string;
    'organization': string;
    'carrier': Carrier;
    'organizationType': OrganizationType;
    'connectionType': string;
    'lineSpeed': string;
    'ipRouteType': string;
    'hostingFacility': string;
}

export class Operation {
    'name': string;
    'requiredInputs': Array<InputParameter>;
    'optionalInputs': Array<InputParameter>;
    'outputs': Array<OutputParameter>;
    'supportLevels': Array<SupportLevel>;
}

export class OrganizationType {
    'naicsCode': string;
    'isicCode': string;
    'value': string;
}

export class OutputParameter {
    'name': string;
    'description': string;
    'type': string;
}

export class PBKeyAddressRequest {
    'addresses': Array<CommonAddress>;
}

export class PBKeyResponse {
    'key': string;
    'matchedAddress': MatchedAddress;
}

export class PBKeyResponseList {
    'pbkey': Array<PbKey>;
}

export class PSAPResponse {
    'fccId': string;
    'type': string;
    'count': number;
    'agency': string;
    'phone': string;
    'county': County;
    'coverage': Coverage;
    'contactPerson': ContactPerson;
    'siteDetails': SiteDetails;
    'mailingAddress': MatchedAddress;
}

export class PbKey {
    'objectId': string;
    'key': string;
    'matchedAddress': MatchedAddress;
}

export class Photo {
    'label': string;
    'value': string;
}

export class Place {
    'level': string;
    'levelName': string;
    'name': Array<Name>;
}

export class PlaceByLocations {
    'location': Array<PlaceByLocationsLocation>;
}

export class PlaceByLocationsLocation {
    'place': PlaceLocation;
}

export class PlaceLocation {
    'level': string;
    'levelName': string;
    'name': Array<PlaceLocationName>;
}

export class PlaceLocationName {
    'langType': string;
    'langISOCode': string;
    'value': string;
}

export class Poi {
    'langISOCode': string;
    'langType': string;
    'displayName': string;
    'name': string;
    'alias': string;
    'brandName': string;
    'categoryCode': number;
    'open24Hours': string;
    'contactDetails': ContactDetails;
    'distance': Distance;
    'latitude': string;
    'longitude': string;
    'customValue1': string;
    'customValue2': string;
    'customValue3': string;
    'customValue4': string;
    'customValue5': string;
    'customValue6': string;
    'customValue7': string;
    'customValue8': string;
    'customValue9': string;
    'customValue10': string;
}

export class PoiByLocation {
    'location': Array<PoiLocation>;
}

export class PoiLocation {
    'dataset': string;
    'poi': Poi;
    'distance': Distance;
    'geometry': Geometry;
}

export class Points {
    'objectId': string;
    'country': string;
    'geometry': GeoPos;
}

export class PolygonGeometry {
    'type': string;
    'coordinates': Array<Array<Array<number>>>;
}

export class PopulationTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariableV2>;
    'rangeVariable': Array<RangeVariableV2>;
}

export class Preferences {
    'fallbackToGeographic': string;
    'useGeoTaxAuxiliaryFile': string;
    'matchMode': string;
    'latLongOffset': string;
    'squeeze': string;
    'latLongFormat': string;
    'defaultBufferWidth': string;
    'distanceUnits': string;
    'outputCasing': string;
    'returnCensusFields': string;
    'returnLatLongFields': string;
    'customPreferences': CustomPreferences;
}

export class PrimaryZone {
    'code': string;
    'description': string;
}

export class Profile {
    'username': string;
    'userid': string;
    'url': string;
    'bio': string;
    'service': string;
    'followers': number;
    'following': number;
}

export class Properties {
    'name': string;
}

export class Property {
    'type': string;
    'estimatedMarketValue': string;
}

export class Proxy {
    'anonymizerStatus': string;
    'level': string;
    'lastDetected': string;
    'type': string;
}

export class PurchasingBehaviorTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariable>;
    'rangeVariable': Array<RangeVariable>;
}

export class RaceAndEthnicityTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariableV2>;
    'rangeVariable': Array<RangeVariableV2>;
}

export class RaceTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariable>;
    'rangeVariable': Array<RangeVariable>;
}

export class RangeVariable {
    'count': string;
    'order': string;
    'name': string;
    'description': string;
    'field': Array<Field>;
}

export class RangeVariableV2 {
    'count': string;
    'order': string;
    'name': string;
    'alias': string;
    'description': string;
    'baseVariable': string;
    'year': string;
    'field': Array<FieldV2>;
}

export class Rate {
    'name': string;
    'format': string;
    'formatDescription': string;
    'value': string;
}

export class RateCenterResponse {
    'id': string;
    'name': string;
    'alternateName': string;
    'areaName1': string;
    'geometry': Geometry;
    'areaCodeInfoList': Array<AreaCodeInfo>;
    'matchedAddress': MatchedAddress;
    'match': Match;
    'county': County;
    'count': number;
    'productCode': string;
}

export class ReturnFieldsDescriptor {
    'returnAllCustomFields': boolean;
    'returnMatchDescriptor': boolean;
    'returnStreetAddressFields': boolean;
    'returnUnitInformation': boolean;
    'returnedCustomFieldKeys': Array<string>;
}

export class ReverseGeocodeRequest {
    'preferences': Preferences;
    'points': Array<Points>;
}

export class Risk {
    'type': string;
    'description': string;
    'risk50Rating': number;
    'frequency': number;
    'nonburn': string;
    'pastFires': number;
    'severity': number;
    'continuity': string;
    'adjustment': string;
    'aspect': string;
    'crownFire': string;
    'vegetation': string;
    'foehn': string;
    'golfCourse': string;
    'roadDist': string;
    'slope': string;
    'waterDist': string;
    'tier': string;
    'tierDescription': string;
    'distanceToFireStation': number;
}

export class RiskAddress {
    'objectId': string;
    'formattedAddress': string;
    'mainAddressLine': string;
    'addressLastLine': string;
    'placeName': string;
    'areaName1': string;
    'areaName2': string;
    'areaName3': string;
    'areaName4': string;
    'postCode': string;
    'postCodeExt': string;
    'country': string;
    'addressNumber': string;
    'streetName': string;
    'unitType': string;
    'unitValue': string;
}

export class RouteBoundary {
    'id': string;
    'type': string;
    'ref': string;
    'geometry': GeoPostGeometry;
}

export class RouteDelivery {
    'individualValueVariable': Array<IndividualValueVariable>;
}

export class RouteDirection {
    'distance': number;
    'distanceUnit': string;
    'timeUnit': string;
    'time': number;
    'instruction': string;
    'directionGeometry': RouteGeometry;
}

export class RouteDirections extends Array<RouteDirection> {
}

export class RouteGeometry {
    'type': string;
    'coordinates': Array<Array<number>>;
}

export class SalesTax {
    'totalTax': number;
    'totalTaxRate': number;
    'totalTaxAmount': number;
    'stateTax': number;
    'stateTaxRate': number;
    'countyTax': number;
    'countyTaxRate': number;
    'countyTaxAmount': number;
    'municipalTax': number;
    'municipalTaxRate': number;
    'municipalTaxAmount': number;
    'spdsTax': Array<SpecialPurposeDistrictTaxRate>;
    'specialTaxRulesApplied': boolean;
    'specialTaxRulesDescriptor': string;
}

export class SalesTaxRate {
    'totalTaxRate': number;
    'stateTaxRate': number;
    'countyTaxRate': number;
    'municipalTaxRate': number;
    'spdsTax': Array<SpecialPurposeDistrictTaxRate>;
}

export class Segmentation {
    'boundaries': Boundaries;
    'themes': SegmentationThemes;
}

export class SegmentationThemes {
    'lifeStyleTheme': LifeStyleTheme;
}

export class ShoreLineDistance {
    'unit': string;
    'value': string;
}

export class SiteDetails {
    'phone': string;
    'fax': string;
    'address': MatchedAddress;
}

export class SpecialPurposeDistrict {
    'districtName': string;
    'districtCode': string;
    'districtNumber': string;
    'versionDate': string;
    'effectiveDate': string;
    'compiledDate': string;
    'updateDate': string;
}

export class SpecialPurposeDistrictTax {
    'districtNumber': string;
    'taxRate': number;
    'taxAmount': number;
}

export class SpecialPurposeDistrictTaxRate {
    'districtNumber': string;
    'taxRate': number;
    'taxAmount': number;
}

export class Start {
    'year': number;
    'month': number;
    'day': number;
}

export class StartEndPoint {
    'type': string;
    'coordinates': Array<number>;
}

export class Status {
    'code': string;
    'description': string;
}

export class SupplyAndDemandTheme {
    'boundaryRef': string;
    'individualValueVariable': Array<IndividualValueVariableV2>;
    'rangeVariable': Array<RangeVariableV2>;
}

export class SupportLevel {
    'supportedDataLevel': number;
    'countries': Array<string>;
    'updatedRequiredInputs': Array<InputParameter>;
    'updatedOptionalInputs': Array<InputParameter>;
    'updatedOptionalOutputs': Array<OutputParameter>;
}

export class TaxAddress {
    'objectId': string;
    'mainAddressLine': string;
    'placeName': string;
    'areaName1': string;
    'areaName3': string;
    'postCode1': string;
    'country': string;
    'purchaseAmount': string;
}

export class TaxAddressRequest {
    'preferences': Preferences;
    'taxAddresses': Array<TaxAddress>;
}

export class TaxBatchLocationResponse {
    'objectId': string;
    'confidence': number;
    'jurisdiction': TaxJurisdiction;
    'matchedAddress': MatchedAddress;
    'salesTax': SalesTax;
    'useTax': UseTax;
    'census': Census;
}

export class TaxBatchResponse {
    'objectId': string;
    'confidence': number;
    'jurisdiction': TaxJurisdiction;
    'matchedAddress': MatchedAddress;
    'salesTax': SalesTax;
    'useTax': UseTax;
    'census': Census;
    'latLongFields': LatLongFields;
}

export class TaxCounty {
    'code': string;
    'name': string;
}

export class TaxDistrictResponse {
    'objectId': string;
    'confidence': number;
    'jurisdiction': IPDTaxJurisdiction;
    'numOfIpdsFound': number;
    'ipds': Array<Ipd>;
    'matchedAddress': MatchedAddress;
}

export class TaxDistrictResponseList {
    'taxDistrictResponse': Array<TaxDistrictResponse>;
}

export class TaxJurisdiction {
    'state': TaxState;
    'county': TaxCounty;
    'place': TaxPlace;
    'spds': Array<SpecialPurposeDistrict>;
}

export class TaxLocationPreferences {
    'defaultBufferWidth': string;
    'distanceUnits': string;
    'outputCasing': string;
    'returnCensusFields': string;
    'returnLatLongFields': string;
}

export class TaxLocationRequest {
    'preferences': TaxLocationPreferences;
    'locations': Array<GeoTaxLocations>;
}

export class TaxLocationResponses {
    'taxResponses': Array<TaxBatchLocationResponse>;
}

export class TaxPlace {
    'name': string;
    'code': string;
    'classCode': string;
    'incorporatedFlag': string;
    'lastAnnexedDate': string;
    'lastUpdatedDate': string;
    'lastVerifiedDate': string;
}

export class TaxRateAddress {
    'objectId': string;
    'mainAddressLine': string;
    'placeName': string;
    'areaName1': string;
    'areaName3': string;
    'postCode1': string;
    'country': string;
}

export class TaxRateAddressRequest {
    'preferences': Preferences;
    'taxRateAddresses': Array<TaxRateAddress>;
}

export class TaxRateBatchLocationResponse {
    'objectId': string;
    'confidence': number;
    'jurisdiction': TaxJurisdiction;
    'matchedAddress': MatchedAddress;
    'salesTax': SalesTaxRate;
    'useTax': UseTaxRate;
    'census': Census;
}

export class TaxRateBatchResponse {
    'objectId': string;
    'confidence': number;
    'jurisdiction': TaxJurisdiction;
    'matchedAddress': MatchedAddress;
    'salesTax': SalesTaxRate;
    'useTax': UseTaxRate;
    'census': Census;
    'latLongFields': LatLongFields;
}

export class TaxRateLocationRequest {
    'preferences': TaxLocationPreferences;
    'locations': Array<GeoTaxRateLocations>;
}

export class TaxRateLocationResponses {
    'taxResponses': Array<TaxRateBatchLocationResponse>;
}

export class TaxRateResponse {
    'objectId': string;
    'confidence': number;
    'jurisdiction': TaxJurisdiction;
    'matchedAddress': MatchedAddress;
    'salesTax': SalesTaxRate;
    'useTax': UseTaxRate;
}

export class TaxRateResponses {
    'taxResponses': Array<TaxRateBatchResponse>;
}

export class TaxResponse {
    'objectId': string;
    'confidence': number;
    'jurisdiction': TaxJurisdiction;
    'matchedAddress': MatchedAddress;
    'salesTax': SalesTax;
    'useTax': UseTax;
}

export class TaxResponses {
    'taxResponses': Array<TaxBatchResponse>;
}

export class TaxState {
    'code': string;
    'name': string;
}

export class Time {
    'value': string;
    'unit': string;
}

export class Timezone {
    'timezoneName': string;
    'zoneType': string;
    'utcOffset': number;
    'dstOffset': number;
    'timestamp': number;
    'matchedAddress': MatchedAddress;
}

export class TimezoneLocation {
    'timezoneName': string;
    'zoneType': string;
    'utcOffset': number;
    'dstOffset': number;
    'timestamp': number;
}

export class Topic {
    'name': string;
}

export class TravelBoundaries {
    'travelBoundary': TravelBoundary;
}

export class TravelBoundary {
    'costs': Costs;
}

export class TravelCostMatrixResponse {
    'matrix': Array<Matrix>;
}

export class Type {
    'code': string;
    'value': string;
}

export class Url {
    'label': string;
    'value': string;
}

export class UseTax {
    'totalTaxRate': number;
    'totalTaxAmount': number;
    'stateTaxRate': number;
    'stateTaxAmount': number;
    'countyTaxRate': number;
    'countyTaxAmount': number;
    'municipalTaxRate': number;
    'municipalTaxAmount': number;
    'spdsTax': Array<SpecialPurposeDistrictTax>;
    'specialTaxRulesApplied': boolean;
    'specialTaxRulesDescriptor': string;
}

export class UseTaxRate {
    'totalTaxRate': number;
    'stateTaxRate': number;
    'countyTaxRate': number;
    'municipalTaxRate': number;
    'spdsTax': Array<SpecialPurposeDistrictTaxRate>;
}

export class WaterBody {
    'name': string;
    'distance': ShoreLineDistance;
    'type': Type;
}

export class WaterBodyLocationResponse {
    'waterBody': Array<WaterBody>;
}

export class WaterBodyResponse {
    'waterBody': Array<WaterBody>;
    'matchedAddress': MatchedAddress;
}


export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    getOAuthCredentials(requestOptions: request.Options): Promise<{body: oAuthCredInfo;  }>;
}

/*export class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}*/

/*export class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: request.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header") {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}*/

    export class OAuth implements Authentication {
    public objOAuthCredInfo: oAuthCredInfo;

    public oAuthApiKey : string;
    public oAuthSecret : string;
    public oAuthUrl :string;
    public oAuthToken :string;

    constructor()
    constructor(oAuthApiKey?: string, oAuthSecret?: string) {
    this.oAuthApiKey=oAuthApiKey;
    this.oAuthSecret=oAuthSecret;
    }


    public getOAuthCredentials(): Promise<{ response: http.IncomingMessage; body: oAuthCredInfo; }> {

    if (this.oAuthApiKey === undefined || this.oAuthSecret === undefined ) {
    Promise.reject({response: "Validation Error", body: "oAuthApiKey or oAuthSecret missing"})
    }

    if ((this.objOAuthCredInfo === null || this.objOAuthCredInfo === undefined)) {

    return this.refreshToken();

    }
    else {

    if((Number(this.objOAuthCredInfo.issuedAt) + Number(this.objOAuthCredInfo.expiresIn)) < (moment().valueOf()+ 10000))
    {
    return this.refreshToken();
    }
    return Promise.resolve({response: null, body: this.objOAuthCredInfo})
    }

    }

    private refreshToken():Promise<{ response: http.IncomingMessage; body: oAuthCredInfo; }>{
    this.oAuthToken = "Basic " + new Buffer(this.oAuthApiKey + ":" + this.oAuthSecret).toString('base64')
    //.toString('base64');
    if (this.oAuthUrl === undefined || this.oAuthUrl === null) {
    this.oAuthUrl = "https://api.pitneybowes.com/oauth/token";
    }

    let requestOptions: request.Options = {
    method: 'POST',
    url: this.oAuthUrl,
    headers:
    {
    'cache-control': 'no-cache',
    authorization: this.oAuthToken
    },
    body: 'grant_type=client_credentials'
    };

    return new Promise<{ response: http.IncomingMessage; body: oAuthCredInfo; }>((resolve, reject) => {
    request(requestOptions, (error, response, body) => {
    if (error) {
    reject({response: response, body: JSON.parse(error)});
    } else {
    if (response.statusCode >= 200 && response.statusCode <= 299) {
    this.objOAuthCredInfo = JSON.parse(body);
    resolve({response: response, body: JSON.parse(body)});
    } else {
    reject({response: response, body: JSON.parse(body)});
    }
    }
    });
    });
    }
    }

/*export class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        // Do nothing
    }
}*/

export enum LIAPIGeo911ServiceApiApiKeys {
}

export class LIAPIGeo911ServiceApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications : OAuth;
    protected  oAuthCred : oAuthCredInfo;

    /*protected authentications = {
       // 'default': <Authentication>new VoidAuth(),
        'oAuth2Password': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }*/

    constructor(oAuthObj: oAuthCredInfo);
    constructor(oAuthObj: oAuthCredInfo,basePath?: string)
    {
    if(oAuthObj)
    {
    this.oAuthCred=oAuthObj;
    }
    if (basePath) {
    this.basePath = basePath;
    }
    }
    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: LIAPIGeo911ServiceApiApiKeys, value: string) {
        this.authentications[LIAPIGeo911ServiceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.objOAuthCredInfo.access_token = token;
    }
    
    /**
     * AHJ &amp; PSAP By Address.
     * Accepts addresses as input and Returns contact details for Authorities Having Jurisdiction (AHJ) on-behalf-of local Public Safety Answering Points (PSAP). Geo911 accepts an address and returns PSAP contact data plus contact data for an AHJ to communicate directly with a PSAP. Details include agency name, phone number, city name, coverage, contact person&#39;s details, site details and mailing addresses for EMS, Fire, and Police PSAP contacts.
     * @param address The address to be searched.
     */
    public getAHJPlusPSAPByAddress (address: string) : Promise<{ response: http.IncomingMessage; body: AHJPlusPSAPResponse;  }> {
        const localVarPath = this.basePath + '/geo911/v1/ahj-psap/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter address was null or undefined when calling getAHJPlusPSAPByAddress."}]}})
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: AHJPlusPSAPResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * AHJ &amp; PSAP By Location
     * Accepts latitude &amp; longitude as input and Returns contact details for Authorities Having Jurisdiction (AHJ) on-behalf-of local Public Safety Answering Points (PSAP). Geo911 accepts a location coordinate and returns PSAP contact data plus contact data for an AHJ to communicate directly with a PSAP. Details include agency name, phone number, city name, coverage, contact person&#39;s details, site details and mailing addresses for EMS, Fire, and Police PSAP contacts.
     * @param longitude Longitude of the location.
     * @param latitude Latitude of the location.
     */
    public getAHJPlusPSAPByLocation (longitude: string, latitude: string) : Promise<{ response: http.IncomingMessage; body: AHJPlusPSAPResponse;  }> {
        const localVarPath = this.basePath + '/geo911/v1/ahj-psap/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter longitude was null or undefined when calling getAHJPlusPSAPByLocation."}]}})
        }

        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter latitude was null or undefined when calling getAHJPlusPSAPByLocation."}]}})
        }

        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: AHJPlusPSAPResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * PSAP By Address.
     * Accepts addresses as input and returns contact details for local Public Safety Answering Points (PSAP). Geo911 accepts an address as input and returns the relevant PSAP address and contact details including agency name, phone number, county name, coverage, contact person&#39;s details, site details and mailing address.
     * @param address The address to be searched.
     */
    public getPSAPByAddress (address: string) : Promise<{ response: http.IncomingMessage; body: PSAPResponse;  }> {
        const localVarPath = this.basePath + '/geo911/v1/psap/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter address was null or undefined when calling getPSAPByAddress."}]}})
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: PSAPResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * PSAP By Location.
     * Accepts latitude &amp; longitude as input and Returns contact details for local Public Safety Answering Points (PSAP). Geo911 accepts a location coordinate and returns the relevant PSAP address and contact details including dispatch name, phone number, county name, coverage, contact person&#39;s details, site details and mailing address.
     * @param longitude Longitude of the location.
     * @param latitude Latitude of the location.
     */
    public getPSAPByLocation (longitude: string, latitude: string) : Promise<{ response: http.IncomingMessage; body: PSAPResponse;  }> {
        const localVarPath = this.basePath + '/geo911/v1/psap/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter longitude was null or undefined when calling getPSAPByLocation."}]}})
        }

        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter latitude was null or undefined when calling getPSAPByLocation."}]}})
        }

        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: PSAPResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
}
export enum LIAPIGeoCommServiceApiApiKeys {
}

export class LIAPIGeoCommServiceApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications : OAuth;
    protected  oAuthCred : oAuthCredInfo;

    /*protected authentications = {
       // 'default': <Authentication>new VoidAuth(),
        'oAuth2Password': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }*/

    constructor(oAuthObj: oAuthCredInfo);
    constructor(oAuthObj: oAuthCredInfo,basePath?: string)
    {
    if(oAuthObj)
    {
    this.oAuthCred=oAuthObj;
    }
    if (basePath) {
    this.basePath = basePath;
    }
    }
    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: LIAPIGeoCommServiceApiApiKeys, value: string) {
        this.authentications[LIAPIGeoCommServiceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.objOAuthCredInfo.access_token = token;
    }
    
    /**
     * Rate Center By Address.
     * Accepts addresses as input and returns Incumbent Local Exchange Carrier (ILEC) doing-business-as names.
     * @param address The address to be searched.
     * @param country 3 letter ISO code of the country to be searched. Allowed values USA,CAN
     * @param areaCodeInfo Specifies whether area code information will be part of response.Allowed values True,False
     * @param level Level (basic/detail).Allowed values detail,basic.
     */
    public getRateCenterByAddress (address: string, country?: string, areaCodeInfo?: string, level?: string) : Promise<{ response: http.IncomingMessage; body: RateCenterResponse;  }> {
        const localVarPath = this.basePath + '/geocomm/v1/ratecenter/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter address was null or undefined when calling getRateCenterByAddress."}]}})
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        if (country !== undefined) {
            queryParameters['country'] = country;
        }

        if (areaCodeInfo !== undefined) {
            queryParameters['AreaCodeInfo'] = areaCodeInfo;
        }

        if (level !== undefined) {
            queryParameters['level'] = level;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: RateCenterResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Rate Center By Location.
     * Accepts latitude &amp; longitude as input and returns Incumbent Local Exchange Carrier (ILEC) doing-business-as names.
     * @param longitude Longitude of the location.
     * @param latitude Latitude of the location.
     * @param areaCodeInfo Specifies whether area code information will be part of response.Allowed values True,False.
     * @param level Level (basic/detail).Allowed values detail,basic.
     */
    public getRateCenterByLocation (longitude: string, latitude: string, areaCodeInfo?: string, level?: string) : Promise<{ response: http.IncomingMessage; body: RateCenterResponse;  }> {
        const localVarPath = this.basePath + '/geocomm/v1/ratecenter/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter longitude was null or undefined when calling getRateCenterByLocation."}]}})
        }

        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter latitude was null or undefined when calling getRateCenterByLocation."}]}})
        }

        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        if (areaCodeInfo !== undefined) {
            queryParameters['AreaCodeInfo'] = areaCodeInfo;
        }

        if (level !== undefined) {
            queryParameters['level'] = level;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: RateCenterResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
}
export enum LIAPIGeoEnrichServiceApiApiKeys {
}

export class LIAPIGeoEnrichServiceApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications : OAuth;
    protected  oAuthCred : oAuthCredInfo;

    /*protected authentications = {
       // 'default': <Authentication>new VoidAuth(),
        'oAuth2Password': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }*/

    constructor(oAuthObj: oAuthCredInfo);
    constructor(oAuthObj: oAuthCredInfo,basePath?: string)
    {
    if(oAuthObj)
    {
    this.oAuthCred=oAuthObj;
    }
    if (basePath) {
    this.basePath = basePath;
    }
    }
    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: LIAPIGeoEnrichServiceApiApiKeys, value: string) {
        this.authentications[LIAPIGeoEnrichServiceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.objOAuthCredInfo.access_token = token;
    }
    
    /**
     * Address By Location.
     * This service accepts longitude and latitude as input and returns an address for that location.
     * @param latitude Latitude of the location.
     * @param longitude Longitude of the location.
     * @param searchRadius Radius range within which search is performed.
     * @param searchRadiusUnit Radius unit such as feet, kilometers, miles or meters.
     */
    public getAddress (latitude: string, longitude: string, searchRadius?: string, searchRadiusUnit?: string) : Promise<{ response: http.IncomingMessage; body: Locations;  }> {
        const localVarPath = this.basePath + '/geoenrich/v1/address/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter latitude was null or undefined when calling getAddress."}]}})
        }

        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter longitude was null or undefined when calling getAddress."}]}})
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        if (searchRadius !== undefined) {
            queryParameters['searchRadius'] = searchRadius;
        }

        if (searchRadiusUnit !== undefined) {
            queryParameters['searchRadiusUnit'] = searchRadiusUnit;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: Locations;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Points Of Interest By Location.
     * Identifies and retrieves Points of Interest that exist around a specific location (ordered by distance from the location).
     * @param longitude Longitude of the location.
     * @param latitude Latitude of the location.
     * @param brandName Specifies the name of the brand to be searched. Also performs search on partially specified brand names.
     * @param category Specific Category/Categories for which the POI search is performed. (Categories 10020102,10020103 are for Chinese and Italian Restaurants .https://developer2.pitneybowes.com/docs/location-intelligence/v1/en/poicategory/EightDigitPOICategoryCodes.xlsx 
     * @param maxCandidates Maximum number of POIs that can be retrieved.
     * @param searchRadius Radius range within which search is performed.
     * @param searchRadiusUnit Radius unit such as Feet, Kilometers, Miles or Meters.
     * @param searchDataset The datasets upon which the POI search can be performed.
     * @param searchPriority Search order of POI datasets mentioned in searchDataset.
     * @param travelTime Specifies the travel time within which method searches for results (POIs which can be reached within travel time)the search boundary in terms of time mentioned in &#39;travelTimeUnit&#39;. The results are retrieved from the polygon formed based on the travel time specified. This means search can be done in the mentioned time results be from the mentioned time.
     * @param travelTimeUnit Specifies acceptable time units.Allowed values Minutes,Hours,Seconds and Milliseconds
     * @param travelDistance Specifies the search boundary in terms of distance mentioned in &#39;travelDistanceUnit&#39;. The results are retrieved from the polygon formed based on the travel distance specified.
     * @param travelDistanceUnit Specifies acceptable time units.Allowed values Feet,Kilometers,Miles and Meters
     * @param mode Specifies the available mode of commute. This is required when u r trying to do search by travel distance or travel time.Allowed values driving and walking
     */
    public getEntityByLocation (longitude: string, latitude: string, brandName?: string, category?: string, maxCandidates?: string, searchRadius?: string, searchRadiusUnit?: string, searchDataset?: string, searchPriority?: string, travelTime?: string, travelTimeUnit?: string, travelDistance?: string, travelDistanceUnit?: string, mode?: string) : Promise<{ response: http.IncomingMessage; body: PoiByLocation;  }> {
        const localVarPath = this.basePath + '/geoenrich/v1/poi/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter longitude was null or undefined when calling getEntityByLocation."}]}})
        }

        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter latitude was null or undefined when calling getEntityByLocation."}]}})
        }

        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        if (brandName !== undefined) {
            queryParameters['brandName'] = brandName;
        }

        if (category !== undefined) {
            queryParameters['category'] = category;
        }

        if (maxCandidates !== undefined) {
            queryParameters['maxCandidates'] = maxCandidates;
        }

        if (searchRadius !== undefined) {
            queryParameters['searchRadius'] = searchRadius;
        }

        if (searchRadiusUnit !== undefined) {
            queryParameters['searchRadiusUnit'] = searchRadiusUnit;
        }

        if (searchDataset !== undefined) {
            queryParameters['searchDataset'] = searchDataset;
        }

        if (searchPriority !== undefined) {
            queryParameters['searchPriority'] = searchPriority;
        }

        if (travelTime !== undefined) {
            queryParameters['travelTime'] = travelTime;
        }

        if (travelTimeUnit !== undefined) {
            queryParameters['travelTimeUnit'] = travelTimeUnit;
        }

        if (travelDistance !== undefined) {
            queryParameters['travelDistance'] = travelDistance;
        }

        if (travelDistanceUnit !== undefined) {
            queryParameters['travelDistanceUnit'] = travelDistanceUnit;
        }

        if (mode !== undefined) {
            queryParameters['mode'] = mode;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: PoiByLocation;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Place By Location.
     * Identifies and retrieves the nearest neighborhood around a specific location. This GeoEnrich service accepts latitude &amp; longitude as input and returns a place name.
     * @param longitude Longitude of the location.
     * @param latitude Latitude of the location.
     * @param levelHint Numeric code of geographic hierarchy level which is classified at six levels.Allowed values 1,2,3,4,5,6
     */
    public getPlaceByLocation (longitude: string, latitude: string, levelHint?: string) : Promise<{ response: http.IncomingMessage; body: PlaceByLocations;  }> {
        const localVarPath = this.basePath + '/geoenrich/v1/place/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter longitude was null or undefined when calling getPlaceByLocation."}]}})
        }

        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter latitude was null or undefined when calling getPlaceByLocation."}]}})
        }

        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        if (levelHint !== undefined) {
            queryParameters['levelHint'] = levelHint;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: PlaceByLocations;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
}
export enum LIAPIGeoIdentityServiceApiApiKeys {
}

export class LIAPIGeoIdentityServiceApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications : OAuth;
    protected  oAuthCred : oAuthCredInfo;

    /*protected authentications = {
       // 'default': <Authentication>new VoidAuth(),
        'oAuth2Password': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }*/

    constructor(oAuthObj: oAuthCredInfo);
    constructor(oAuthObj: oAuthCredInfo,basePath?: string)
    {
    if(oAuthObj)
    {
    this.oAuthCred=oAuthObj;
    }
    if (basePath) {
    this.basePath = basePath;
    }
    }
    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: LIAPIGeoIdentityServiceApiApiKeys, value: string) {
        this.authentications[LIAPIGeoIdentityServiceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.objOAuthCredInfo.access_token = token;
    }
    
    /**
     * Gets GeoIdentityResponse
     * Gets GeoIdentityResponse
     * @param address free form address text
     * @param givenName This filters all the associated identities of address by given Name
     * @param familyName This filters all the associated identities of address by family Name
     * @param confidence To adjust quality threshold of data returned. Default is HIGH
     * @param maxCandidates Number of identities returned in response
     * @param includeNeighborhoodDetails Whether to include neighborhood details in the response or not. Default is Y
     */
    public getIdentityByAddress (address: string, givenName?: string, familyName?: string, confidence?: string, maxCandidates?: string, includeNeighborhoodDetails?: string) : Promise<{ response: http.IncomingMessage; body: GeoIdentityResponse;  }> {
        const localVarPath = this.basePath + '/geoidentity/v1/identity/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter address was null or undefined when calling getIdentityByAddress."}]}})
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        if (givenName !== undefined) {
            queryParameters['givenName'] = givenName;
        }

        if (familyName !== undefined) {
            queryParameters['familyName'] = familyName;
        }

        if (confidence !== undefined) {
            queryParameters['confidence'] = confidence;
        }

        if (maxCandidates !== undefined) {
            queryParameters['maxCandidates'] = maxCandidates;
        }

        if (includeNeighborhoodDetails !== undefined) {
            queryParameters['includeNeighborhoodDetails'] = includeNeighborhoodDetails;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: GeoIdentityResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Gets Identity
     * Gets Identity
     * @param email This specifies the email address
     * @param confidence To adjust quality threshold of data returned. Default is HIGH
     */
    public getIdentityByEmail (email: string, confidence?: string) : Promise<{ response: http.IncomingMessage; body: Identity;  }> {
        const localVarPath = this.basePath + '/geoidentity/v1/identity/byemail';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'email' is not null or undefined
        if (email === null || email === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter email was null or undefined when calling getIdentityByEmail."}]}})
        }

        if (email !== undefined) {
            queryParameters['email'] = email;
        }

        if (confidence !== undefined) {
            queryParameters['confidence'] = confidence;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: Identity;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Gets GeoIdentityResponse
     * Gets GeoIdentityResponse
     * @param pbKey PB specific unique key for each address
     * @param givenName This filters all the associated identities of address by given Name
     * @param familyName This filters all the associated identities of address by family Name
     * @param confidence To adjust quality threshold of data returned. Default is HIGH
     * @param maxCandidates Number of identities returned in response
     * @param includeNeighborhoodDetails Whether to include neighborhood details in the response or not. Default is Y
     */
    public getIdentityByPBKey (pbKey: string, givenName?: string, familyName?: string, confidence?: string, maxCandidates?: string, includeNeighborhoodDetails?: string) : Promise<{ response: http.IncomingMessage; body: GeoIdentityResponse;  }> {
        const localVarPath = this.basePath + '/geoidentity/v1/identity/bypbkey';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'pbKey' is not null or undefined
        if (pbKey === null || pbKey === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter pbKey was null or undefined when calling getIdentityByPBKey."}]}})
        }

        if (pbKey !== undefined) {
            queryParameters['pbKey'] = pbKey;
        }

        if (givenName !== undefined) {
            queryParameters['givenName'] = givenName;
        }

        if (familyName !== undefined) {
            queryParameters['familyName'] = familyName;
        }

        if (confidence !== undefined) {
            queryParameters['confidence'] = confidence;
        }

        if (maxCandidates !== undefined) {
            queryParameters['maxCandidates'] = maxCandidates;
        }

        if (includeNeighborhoodDetails !== undefined) {
            queryParameters['includeNeighborhoodDetails'] = includeNeighborhoodDetails;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: GeoIdentityResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
}
export enum LIAPIGeoLifeServiceApiApiKeys {
}

export class LIAPIGeoLifeServiceApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications : OAuth;
    protected  oAuthCred : oAuthCredInfo;

    /*protected authentications = {
       // 'default': <Authentication>new VoidAuth(),
        'oAuth2Password': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }*/

    constructor(oAuthObj: oAuthCredInfo);
    constructor(oAuthObj: oAuthCredInfo,basePath?: string)
    {
    if(oAuthObj)
    {
    this.oAuthCred=oAuthObj;
    }
    if (basePath) {
    this.basePath = basePath;
    }
    }
    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: LIAPIGeoLifeServiceApiApiKeys, value: string) {
        this.authentications[LIAPIGeoLifeServiceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.objOAuthCredInfo.access_token = token;
    }
    
    /**
     * Demographics By Address.
     * Provides the demographic details around a specified address. GeoLife &#39;byaddress&#39; service accepts address as an input to return a specific population segment&#39;s age group, ethnicity, income, purchasing behaviour, commuter patterns and more.
     * @param address The address to be searched.
     * @param country 3 letter ISO code of the country to be searched.Allowed values USA,CAN,GBR,AUS.
     * @param profile Retrieves the sorted demographic data on the basis of pre-defined profiles that can display the top 3 or top 5 results (by address) either in ascending or descending order.Allowed values Top5Ascending,Top5Descending,Top3Ascending,Top3Descending
     * @param filter The &#39;filter&#39; parameter retrieves the demographic data based upon specified input themes.
     * @param valueFormat The &#39;valueFormat&#39; parameter is applicable for few ranged variables where percent &amp; count both are available and filter response based on the input value.
     * @param variableLevel The &#39;variableLevel&#39; retrieves demographic facts in response based on the input value
     */
    public getDemographicsByAddressV2 (address: string, country?: string, profile?: string, filter?: string, valueFormat?: string, variableLevel?: string) : Promise<{ response: http.IncomingMessage; body: DemographicsV2;  }> {
        const localVarPath = this.basePath + '/geolife/v2/demographics/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter address was null or undefined when calling getDemographicsByAddressV2."}]}})
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        if (country !== undefined) {
            queryParameters['country'] = country;
        }

        if (profile !== undefined) {
            queryParameters['profile'] = profile;
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (valueFormat !== undefined) {
            queryParameters['valueFormat'] = valueFormat;
        }

        if (variableLevel !== undefined) {
            queryParameters['variableLevel'] = variableLevel;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: DemographicsV2;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Demographics By Location.
     * Provides the demographic details around a specified location. GeoLife &#39;bylocation&#39; service accepts longitude and latitude as an input to return a specific population segment&#39;s age group, ethnicity, income, purchasing behaviour, commuter patterns and more.
     * @param longitude Longitude of the location.
     * @param latitude Latitude of the location.
     * @param profile Retrieves the sorted demographic data on the basis of pre-defined profiles that can display the top 3 or top 5 results (by location) either in ascending or descending order.Allowed values Top5Ascending,Top5Descending,Top3Ascending,Top3Descending
     * @param filter The &#39;filter&#39; parameter retrieves the demographic data based upon specified input themes.
     * @param valueFormat The &#39;valueFormat&#39; parameter is applicable for few ranged variables where percent &amp; count both are available and filter response based on the input value.
     * @param variableLevel The &#39;variableLevel&#39; retrieves demographic facts in response based on the input value
     */
    public getDemographicsByLocationV2 (longitude: string, latitude: string, profile?: string, filter?: string, valueFormat?: string, variableLevel?: string) : Promise<{ response: http.IncomingMessage; body: DemographicsV2;  }> {
        const localVarPath = this.basePath + '/geolife/v2/demographics/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter longitude was null or undefined when calling getDemographicsByLocationV2."}]}})
        }

        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter latitude was null or undefined when calling getDemographicsByLocationV2."}]}})
        }

        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        if (profile !== undefined) {
            queryParameters['profile'] = profile;
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (valueFormat !== undefined) {
            queryParameters['valueFormat'] = valueFormat;
        }

        if (variableLevel !== undefined) {
            queryParameters['variableLevel'] = variableLevel;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: DemographicsV2;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Demographics By PBKey.
     * Provides the demographic details for a specified PB Key. GeoLife &#39;bypbkey&#39; service accepts pbkey as an input to return a specific population segment&#39;s age group, ethnicity, income, purchasing behaviour, commuter patterns and more.
     * @param pbKey free form text
     * @param profile Retrieves the sorted demographic data on the basis of pre-defined profiles that can display the top 3 or top 5 results (by address) either in ascending or descending order.Allowed values Top5Ascending,Top5Descending,Top3Ascending,Top3Descending
     * @param filter The &#39;filter&#39; parameter retrieves the demographic data based upon specified input themes.
     * @param valueFormat The &#39;valueFormat&#39; parameter is applicable for few ranged variables where percent &amp; count both are available and filter response based on the input value.
     * @param variableLevel The &#39;variableLevel&#39; retrieves demographic facts in response based on the input value
     */
    public getDemographicsByPBKey (pbKey: string, profile?: string, filter?: string, valueFormat?: string, variableLevel?: string) : Promise<{ response: http.IncomingMessage; body: DemographicsV2;  }> {
        const localVarPath = this.basePath + '/geolife/v2/demographics/bypbkey';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'pbKey' is not null or undefined
        if (pbKey === null || pbKey === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter pbKey was null or undefined when calling getDemographicsByPBKey."}]}})
        }

        if (pbKey !== undefined) {
            queryParameters['pbKey'] = pbKey;
        }

        if (profile !== undefined) {
            queryParameters['profile'] = profile;
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (valueFormat !== undefined) {
            queryParameters['valueFormat'] = valueFormat;
        }

        if (variableLevel !== undefined) {
            queryParameters['variableLevel'] = variableLevel;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: DemographicsV2;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Segmentation By Address.
     * Provides the segmentation details around a specified address. GeoLife &#39;Segmentation by Address&#39; service accepts address as an input to return the lifestyle characteristics of households in terms of their family status, children characteristics, income behaviors, financial preferences and interests.
     * @param address The address to be searched.
     * @param country 3 letter ISO code of the country to be searched.Allowed values USA,CAN,GBR,FRA,ITA,AUS,DEU.
     */
    public getSegmentationByAddress (address: string, country?: string) : Promise<{ response: http.IncomingMessage; body: Segmentation;  }> {
        const localVarPath = this.basePath + '/geolife/v1/segmentation/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter address was null or undefined when calling getSegmentationByAddress."}]}})
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        if (country !== undefined) {
            queryParameters['country'] = country;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: Segmentation;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Segmentation By Location.
     * Provides the segmentation details around a specified location. GeoLife &#39;segmentation bylocation&#39; service accepts longitude and latitude as an input to return the lifestyle characteristics of households in terms of their family status, children characteristics, income behaviors, financial preferences and interests.
     * @param longitude Longitude of the location.
     * @param latitude Latitude of the location.
     */
    public getSegmentationByLocation (longitude: string, latitude: string) : Promise<{ response: http.IncomingMessage; body: Segmentation;  }> {
        const localVarPath = this.basePath + '/geolife/v1/segmentation/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter longitude was null or undefined when calling getSegmentationByLocation."}]}})
        }

        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter latitude was null or undefined when calling getSegmentationByLocation."}]}})
        }

        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: Segmentation;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Segmentation By PB Key.
     * Provides the segmentation details for a PB Key. GeoLife &#39;segmentation bypbkey&#39; service accepts free form text PB Key as an input to return the lifestyle characteristics of households in terms of their family status, children characteristics, income behaviors, financial preferences and interests.
     * @param pbKey free form text
     */
    public getSegmentationByPBKey (pbKey: string) : Promise<{ response: http.IncomingMessage; body: Segmentation;  }> {
        const localVarPath = this.basePath + '/geolife/v1/segmentation/bypbkey';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'pbKey' is not null or undefined
        if (pbKey === null || pbKey === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter pbKey was null or undefined when calling getSegmentationByPBKey."}]}})
        }

        if (pbKey !== undefined) {
            queryParameters['pbKey'] = pbKey;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: Segmentation;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
}
export enum LIAPIGeoLocationServiceApiApiKeys {
}

export class LIAPIGeoLocationServiceApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications : OAuth;
    protected  oAuthCred : oAuthCredInfo;

    /*protected authentications = {
       // 'default': <Authentication>new VoidAuth(),
        'oAuth2Password': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }*/

    constructor(oAuthObj: oAuthCredInfo);
    constructor(oAuthObj: oAuthCredInfo,basePath?: string)
    {
    if(oAuthObj)
    {
    this.oAuthCred=oAuthObj;
    }
    if (basePath) {
    this.basePath = basePath;
    }
    }
    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: LIAPIGeoLocationServiceApiApiKeys, value: string) {
        this.authentications[LIAPIGeoLocationServiceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.objOAuthCredInfo.access_token = token;
    }
    
    /**
     * Location By Device Status.
     * This service accepts a phone number as input and returns details distinguishing landline and wireless numbers and also checks if a wireless number can be located.
     * @param deviceId Unique identifier for the intended device. Supported identifiers are fixed line and mobile number.
     * @param includeNetworkInfo  Y or N (default is Y)  if it is N, then network/carrier details will not be added in the response.
     */
    public getDeviceStatus (deviceId: string, includeNetworkInfo ?: string) : Promise<{ response: http.IncomingMessage; body: GeoLocationDeviceSatus;  }> {
        const localVarPath = this.basePath + '/geolocation/v1/devicestatus';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter deviceId was null or undefined when calling getDeviceStatus."}]}})
        }

        if (deviceId !== undefined) {
            queryParameters['deviceId'] = deviceId;
        }

        if (includeNetworkInfo  !== undefined) {
            queryParameters['includeNetworkInfo '] = includeNetworkInfo ;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: GeoLocationDeviceSatus;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Location By Fixed Line Network.
     * This service accepts a fixed line phone number and returns the location coordinates corresponding to that phone number.
     * @param deviceId This is the fixed line phone number (US only). This is a mandatory parameter.
     */
    public getLocationByFixedLine (deviceId: string) : Promise<{ response: http.IncomingMessage; body: GeoLocationFixedLine;  }> {
        const localVarPath = this.basePath + '/geolocation/v1/location/byfixedline';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter deviceId was null or undefined when calling getLocationByFixedLine."}]}})
        }

        if (deviceId !== undefined) {
            queryParameters['deviceId'] = deviceId;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: GeoLocationFixedLine;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Location By IP Address.
     * This service accepts an IP address and returns the location coordinates corresponding to that IP address.
     * @param ipAddress This is the ip address of network connected device. It must be a standard IPv4 octet and a valid external address.
     */
    public getLocationByIPAddress (ipAddress: string) : Promise<{ response: http.IncomingMessage; body: GeoLocationIpAddr;  }> {
        const localVarPath = this.basePath + '/geolocation/v1/location/byipaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'ipAddress' is not null or undefined
        if (ipAddress === null || ipAddress === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter ipAddress was null or undefined when calling getLocationByIPAddress."}]}})
        }

        if (ipAddress !== undefined) {
            queryParameters['ipAddress'] = ipAddress;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: GeoLocationIpAddr;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Location by WiFi Access Point.
     * This service accepts a WiFi access point MAC address and returns the location coordinates corresponding to that access point. Only mac or accessPoint are mandatory parameters (one of them has to be provided), rest are optional.
     * @param mac This should be the 48 bit mac address (or BSSID) of wireless access point. Accepted format is Six groups of two hexadecimal digits, separated by hyphens (-) or colons.
     * @param ssid The service set identifier for wi-fi access point. It should be alphanumeric with maximum 32 characters.
     * @param rsid This is the received signal strength indicator from particular wi-fi access point. It should be a number from -113 to 0 and the unit of this strength is dBm.
     * @param speed This is the connection speed for wi-fi. It should be a number from 0 to 6930 and the unit should be Mbps.
     * @param accessPoint This is the JSON based list of wifi access points in the vicinity of device to be located. This parameter is helpful in case, multiple wifi points are visible and we want to make sure that the location of device is best calculated considering all the access points location.
     */
    public getLocationByWiFiAccessPoint (mac?: string, ssid?: string, rsid?: string, speed?: string, accessPoint?: string) : Promise<{ response: http.IncomingMessage; body: GeoLocationAccessPoint;  }> {
        const localVarPath = this.basePath + '/geolocation/v1/location/byaccesspoint';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        if (mac !== undefined) {
            queryParameters['mac'] = mac;
        }

        if (ssid !== undefined) {
            queryParameters['ssid'] = ssid;
        }

        if (rsid !== undefined) {
            queryParameters['rsid'] = rsid;
        }

        if (speed !== undefined) {
            queryParameters['speed'] = speed;
        }

        if (accessPoint !== undefined) {
            queryParameters['accessPoint'] = accessPoint;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: GeoLocationAccessPoint;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
}
export enum LIAPIGeoPostServiceApiApiKeys {
}

export class LIAPIGeoPostServiceApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications : OAuth;
    protected  oAuthCred : oAuthCredInfo;

    /*protected authentications = {
       // 'default': <Authentication>new VoidAuth(),
        'oAuth2Password': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }*/

    constructor(oAuthObj: oAuthCredInfo);
    constructor(oAuthObj: oAuthCredInfo,basePath?: string)
    {
    if(oAuthObj)
    {
    this.oAuthCred=oAuthObj;
    }
    if (basePath) {
    this.basePath = basePath;
    }
    }
    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: LIAPIGeoPostServiceApiApiKeys, value: string) {
        this.authentications[LIAPIGeoPostServiceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.objOAuthCredInfo.access_token = token;
    }
    
    /**
     * Carrier Route By Address.
     * Get United States Postal Service (USPS) carrier route data for the requested address
     * @param address free form address text
     * @param includeGeometry Y or N (default is Y) - if it is Y, then geometry will be part of response
     */
    public getCarrierRoutesByAddress (address: string, includeGeometry?: string) : Promise<{ response: http.IncomingMessage; body: CarrierRouteResponse;  }> {
        const localVarPath = this.basePath + '/geopost/v1/carrierroute/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter address was null or undefined when calling getCarrierRoutesByAddress."}]}})
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        if (includeGeometry !== undefined) {
            queryParameters['includeGeometry'] = includeGeometry;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: CarrierRouteResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Gets GeoPost Carrier Routes for Multiple Addresses
     * Gets GeoPost Carrier Routes for Multiple Addresses
     * @param body 
     */
    public getCarrierRoutesByAddressBatch (body?: CarrierRouteAddressRequest) : Promise<{ response: http.IncomingMessage; body: CarrierRouteResponseList;  }> {
        const localVarPath = this.basePath + '/geopost/v1/carrierroute/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: CarrierRouteResponseList;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
}
export enum LIAPIGeoPropertyServiceApiApiKeys {
}

export class LIAPIGeoPropertyServiceApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications : OAuth;
    protected  oAuthCred : oAuthCredInfo;

    /*protected authentications = {
       // 'default': <Authentication>new VoidAuth(),
        'oAuth2Password': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }*/

    constructor(oAuthObj: oAuthCredInfo);
    constructor(oAuthObj: oAuthCredInfo,basePath?: string)
    {
    if(oAuthObj)
    {
    this.oAuthCred=oAuthObj;
    }
    if (basePath) {
    this.basePath = basePath;
    }
    }
    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: LIAPIGeoPropertyServiceApiApiKeys, value: string) {
        this.authentications[LIAPIGeoPropertyServiceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.objOAuthCredInfo.access_token = token;
    }
    
    /**
     * Gets GeoPropertyResponse
     * Gets GeoPropertyResponse
     * @param address free form address text
     */
    public getGeoPropertyByAddress (address: string) : Promise<{ response: http.IncomingMessage; body: GeoPropertyResponse;  }> {
        const localVarPath = this.basePath + '/geoproperty/v1/all/attributes/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter address was null or undefined when calling getGeoPropertyByAddress."}]}})
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: GeoPropertyResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Gets GeoPropertyResponses
     * Gets GeoPropertyResponses
     * @param body 
     */
    public getGeoPropertyByAddressBatch (body?: GeoPropertyAddressRequest) : Promise<{ response: http.IncomingMessage; body: GeoPropertyResponses;  }> {
        const localVarPath = this.basePath + '/geoproperty/v1/all/attributes/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: GeoPropertyResponses;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Gets GeoPropertyResponse
     * Gets GeoPropertyResponse
     * @param pbKey free form text
     */
    public getGeoPropertyByPBKey (pbKey: string) : Promise<{ response: http.IncomingMessage; body: GeoPropertyPBKeyResponse;  }> {
        const localVarPath = this.basePath + '/geoproperty/v1/all/attributes/bypbkey';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'pbKey' is not null or undefined
        if (pbKey === null || pbKey === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter pbKey was null or undefined when calling getGeoPropertyByPBKey."}]}})
        }

        if (pbKey !== undefined) {
            queryParameters['pbKey'] = pbKey;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: GeoPropertyPBKeyResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Gets GeoPropertyResponses
     * Gets GeoPropertyResponses
     * @param body 
     */
    public getGeoPropertyByPBKeyBatch (body?: GeoPropertyPBKeyRequest) : Promise<{ response: http.IncomingMessage; body: GeoPropertyPBKeyResponses;  }> {
        const localVarPath = this.basePath + '/geoproperty/v1/all/attributes/bypbkey';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: GeoPropertyPBKeyResponses;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
}
export enum LIAPIGeoRiskServiceApiApiKeys {
}

export class LIAPIGeoRiskServiceApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications : OAuth;
    protected  oAuthCred : oAuthCredInfo;

    /*protected authentications = {
       // 'default': <Authentication>new VoidAuth(),
        'oAuth2Password': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }*/

    constructor(oAuthObj: oAuthCredInfo);
    constructor(oAuthObj: oAuthCredInfo,basePath?: string)
    {
    if(oAuthObj)
    {
    this.oAuthCred=oAuthObj;
    }
    if (basePath) {
    this.basePath = basePath;
    }
    }
    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: LIAPIGeoRiskServiceApiApiKeys, value: string) {
        this.authentications[LIAPIGeoRiskServiceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.objOAuthCredInfo.access_token = token;
    }
    
    /**
     * Gets CrimeRiskResponse
     * Returns the crime data or crime indexes for a given address input.
     * @param address Free-form address text.
     * @param type Type of crime like violent crime, property crime, etc., multiple crime type indexes could be requested as comma separated values with &#39;all&#39; as default.)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response
     */
    public getCrimeRiskByAddress (address: string, type?: string, includeGeometry?: string) : Promise<{ response: http.IncomingMessage; body: CrimeRiskResponse;  }> {
        const localVarPath = this.basePath + '/georisk/v1/crime/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter address was null or undefined when calling getCrimeRiskByAddress."}]}})
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        if (type !== undefined) {
            queryParameters['type'] = type;
        }

        if (includeGeometry !== undefined) {
            queryParameters['includeGeometry'] = includeGeometry;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: CrimeRiskResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Batch method for getting crime risk by address
     * Batch method for getting crime risk by address
     * @param body 
     */
    public getCrimeRiskByAddressBatch (body?: CrimeRiskByAddressRequest) : Promise<{ response: http.IncomingMessage; body: CrimeRiskResponseList;  }> {
        const localVarPath = this.basePath + '/georisk/v1/crime/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: CrimeRiskResponseList;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Gets CrimeRiskResponse
     * Returns the crime data or crime indexes for a given location.
     * @param longitude The longitude of the location
     * @param latitude The latitude of the location
     * @param type Refers to crime type. Valid values are following 11 crime types with &#39;all&#39; as default (more than one can also be given as comma separated types)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response
     */
    public getCrimeRiskByLocation (longitude: string, latitude: string, type?: string, includeGeometry?: string) : Promise<{ response: http.IncomingMessage; body: CrimeRiskLocationResponse;  }> {
        const localVarPath = this.basePath + '/georisk/v1/crime/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter longitude was null or undefined when calling getCrimeRiskByLocation."}]}})
        }

        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter latitude was null or undefined when calling getCrimeRiskByLocation."}]}})
        }

        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        if (type !== undefined) {
            queryParameters['type'] = type;
        }

        if (includeGeometry !== undefined) {
            queryParameters['includeGeometry'] = includeGeometry;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: CrimeRiskLocationResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Batch method for getting crime risk by location
     * Batch method for getting crime risk by location
     * @param body 
     */
    public getCrimeRiskByLocationBatch (body?: CrimeRiskByLocationRequest) : Promise<{ response: http.IncomingMessage; body: CrimeRiskLocationResponseList;  }> {
        const localVarPath = this.basePath + '/georisk/v1/crime/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: CrimeRiskLocationResponseList;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Gets WaterBodyResponse
     * Gets WaterBodyResponse
     * @param address The address of the location
     * @param maxCandidates This specifies the value of maxCandidates
     * @param waterBodyType all (default value), oceanandsea,lake,others,unknown,intermittent
     * @param searchDistance This specifies the search distance
     * @param searchDistanceUnit miles (default value),feet, kilometers, meters
     */
    public getDistanceToFloodHazardByAddress (address: string, maxCandidates?: string, waterBodyType?: string, searchDistance?: string, searchDistanceUnit?: string) : Promise<{ response: http.IncomingMessage; body: WaterBodyResponse;  }> {
        const localVarPath = this.basePath + '/georisk/v1/shoreline/distancetofloodhazard/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter address was null or undefined when calling getDistanceToFloodHazardByAddress."}]}})
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        if (maxCandidates !== undefined) {
            queryParameters['maxCandidates'] = maxCandidates;
        }

        if (waterBodyType !== undefined) {
            queryParameters['waterBodyType'] = waterBodyType;
        }

        if (searchDistance !== undefined) {
            queryParameters['searchDistance'] = searchDistance;
        }

        if (searchDistanceUnit !== undefined) {
            queryParameters['searchDistanceUnit'] = searchDistanceUnit;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: WaterBodyResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Batch method for getting Water Bodies by address
     * Batch method for getting Water Bodies by address
     * @param body 
     */
    public getDistanceToFloodHazardByAddressBatch (body?: DistanceToFloodHazardAddressRequest) : Promise<{ response: http.IncomingMessage; body: DistanceToFloodHazardResponse;  }> {
        const localVarPath = this.basePath + '/georisk/v1/shoreline/distancetofloodhazard/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: DistanceToFloodHazardResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Gets WaterBodyResponse
     * Gets WaterBodyResponse
     * @param longitude The longitude of the location
     * @param latitude The latitude of the location
     * @param maxCandidates This specifies the value of maxCandidates
     * @param waterBodyType all (default value), oceanandsea,lake,others,unknown,intermittent
     * @param searchDistance This specifies the search distance
     * @param searchDistanceUnit miles (default value),feet, kilometers, meters
     */
    public getDistanceToFloodHazardByLocation (longitude: string, latitude: string, maxCandidates?: string, waterBodyType?: string, searchDistance?: string, searchDistanceUnit?: string) : Promise<{ response: http.IncomingMessage; body: WaterBodyLocationResponse;  }> {
        const localVarPath = this.basePath + '/georisk/v1/shoreline/distancetofloodhazard/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter longitude was null or undefined when calling getDistanceToFloodHazardByLocation."}]}})
        }

        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter latitude was null or undefined when calling getDistanceToFloodHazardByLocation."}]}})
        }

        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        if (maxCandidates !== undefined) {
            queryParameters['maxCandidates'] = maxCandidates;
        }

        if (waterBodyType !== undefined) {
            queryParameters['waterBodyType'] = waterBodyType;
        }

        if (searchDistance !== undefined) {
            queryParameters['searchDistance'] = searchDistance;
        }

        if (searchDistanceUnit !== undefined) {
            queryParameters['searchDistanceUnit'] = searchDistanceUnit;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: WaterBodyLocationResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Batch method for getting Water Bodies by location
     * Batch method for getting Water Bodies by location
     * @param body 
     */
    public getDistanceToFloodHazardByLocationBatch (body?: DistanceToFloodHazardLocationRequest) : Promise<{ response: http.IncomingMessage; body: DistanceToFloodHazardLocationResponse;  }> {
        const localVarPath = this.basePath + '/georisk/v1/shoreline/distancetofloodhazard/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: DistanceToFloodHazardLocationResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Gets EarthquakeHistory
     * Gets EarthquakeHistory
     * @param postCode 5 digit Postal code to search
     * @param startDate Start time in milliseconds(UTC)
     * @param endDate End time in milliseconds(UTC)
     * @param minMagnitude Minimum richter scale magnitude
     * @param maxMagnitude Maximum Richter scale magnitude
     * @param maxCandidates Maximum response events
     */
    public getEarthquakeHistory (postCode: string, startDate?: string, endDate?: string, minMagnitude?: string, maxMagnitude?: string, maxCandidates?: string) : Promise<{ response: http.IncomingMessage; body: EarthquakeHistory;  }> {
        const localVarPath = this.basePath + '/georisk/v1/earthquakehistory';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'postCode' is not null or undefined
        if (postCode === null || postCode === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter postCode was null or undefined when calling getEarthquakeHistory."}]}})
        }

        if (postCode !== undefined) {
            queryParameters['postCode'] = postCode;
        }

        if (startDate !== undefined) {
            queryParameters['startDate'] = startDate;
        }

        if (endDate !== undefined) {
            queryParameters['endDate'] = endDate;
        }

        if (minMagnitude !== undefined) {
            queryParameters['minMagnitude'] = minMagnitude;
        }

        if (maxMagnitude !== undefined) {
            queryParameters['maxMagnitude'] = maxMagnitude;
        }

        if (maxCandidates !== undefined) {
            queryParameters['maxCandidates'] = maxCandidates;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: EarthquakeHistory;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Gets EarthquakeRiskResponse
     * Returns the count of earthquake events for various richter measurements and values for an input address.
     * @param address Free-form address text
     * @param richterValue Richter values like R5 (count of richter scale 5 events), R7 (count of richter scale 7 events), R6_GE (count of events &gt;&#x3D; richter scale 6), etc., multiple richter scales could be requested as comma separated values with &#39;all&#39; as default. Valid values: All (default value), R0, R1, R2, R3, R4, R5, R6, R7, R0_GE, R1_GE, R2_GE, R3_GE, R4_GE, R5_GE, R6_GE, R7_GE
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response
     */
    public getEarthquakeRiskByAddress (address: string, richterValue?: string, includeGeometry?: string) : Promise<{ response: http.IncomingMessage; body: EarthquakeRiskResponse;  }> {
        const localVarPath = this.basePath + '/georisk/v1/earthquake/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter address was null or undefined when calling getEarthquakeRiskByAddress."}]}})
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        if (richterValue !== undefined) {
            queryParameters['richterValue'] = richterValue;
        }

        if (includeGeometry !== undefined) {
            queryParameters['includeGeometry'] = includeGeometry;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: EarthquakeRiskResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Batch method for getting earthquake risk by address
     * Batch method for getting earthquake risk by address
     * @param body 
     */
    public getEarthquakeRiskByAddressBatch (body?: EarthquakeRiskByAddressRequest) : Promise<{ response: http.IncomingMessage; body: EarthquakeRiskResponseList;  }> {
        const localVarPath = this.basePath + '/georisk/v1/earthquake/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: EarthquakeRiskResponseList;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Gets EarthquakeRiskResponse
     * Gets EarthquakeRiskResponse
     * @param longitude The longitude of the location
     * @param latitude The latitude of the location
     * @param richterValue Richter values like R5 (count of richter scale 5 events), R7 (count of richter scale 7 events), R6_GE (count of events &gt;&#x3D; richter scale 6), etc., multiple richter scales could be requested as comma separated values with &#39;all&#39; as default. Valid values: All (default value), R0, R1, R2, R3, R4, R5, R6, R7, R0_GE, R1_GE, R2_GE, R3_GE, R4_GE, R5_GE, R6_GE, R7_GE
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response
     */
    public getEarthquakeRiskByLocation (longitude: string, latitude: string, richterValue?: string, includeGeometry?: string) : Promise<{ response: http.IncomingMessage; body: EarthquakeRiskLocationResponse;  }> {
        const localVarPath = this.basePath + '/georisk/v1/earthquake/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter longitude was null or undefined when calling getEarthquakeRiskByLocation."}]}})
        }

        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter latitude was null or undefined when calling getEarthquakeRiskByLocation."}]}})
        }

        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        if (richterValue !== undefined) {
            queryParameters['richterValue'] = richterValue;
        }

        if (includeGeometry !== undefined) {
            queryParameters['includeGeometry'] = includeGeometry;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: EarthquakeRiskLocationResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Batch method for getting earthquake risk by location
     * Batch method for getting earthquake risk by location
     * @param body 
     */
    public getEarthquakeRiskByLocationBatch (body?: EarthquakeRiskByLocationRequest) : Promise<{ response: http.IncomingMessage; body: EarthquakeRiskLocationResponseList;  }> {
        const localVarPath = this.basePath + '/georisk/v1/earthquake/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: EarthquakeRiskLocationResponseList;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Gets FireHistory
     * Gets FireHistory
     * @param postCode 5 digit Postal code to search
     * @param startDate Start time in milliseconds(UTC)
     * @param endDate End time in milliseconds(UTC)
     * @param maxCandidates Maximum response events
     */
    public getFireHistory (postCode: string, startDate?: string, endDate?: string, maxCandidates?: string) : Promise<{ response: http.IncomingMessage; body: FireHistory;  }> {
        const localVarPath = this.basePath + '/georisk/v1/firehistory';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'postCode' is not null or undefined
        if (postCode === null || postCode === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter postCode was null or undefined when calling getFireHistory."}]}})
        }

        if (postCode !== undefined) {
            queryParameters['postCode'] = postCode;
        }

        if (startDate !== undefined) {
            queryParameters['startDate'] = startDate;
        }

        if (endDate !== undefined) {
            queryParameters['endDate'] = endDate;
        }

        if (maxCandidates !== undefined) {
            queryParameters['maxCandidates'] = maxCandidates;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: FireHistory;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Gets FireRiskResponse
     * Returns the fire data based on address input.
     * @param address Free-form address text
     */
    public getFireRiskByAddress (address: string) : Promise<{ response: http.IncomingMessage; body: FireRiskResponse;  }> {
        const localVarPath = this.basePath + '/georisk/v1/fire/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter address was null or undefined when calling getFireRiskByAddress."}]}})
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: FireRiskResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Batch method for getting fire risk by address
     * Batch method for getting fire risk by address
     * @param body 
     */
    public getFireRiskByAddressBatch (body?: FireRiskByAddressRequest) : Promise<{ response: http.IncomingMessage; body: FireRiskResponseList;  }> {
        const localVarPath = this.basePath + '/georisk/v1/fire/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: FireRiskResponseList;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Gets FireRiskResponse
     * Returns the fire data based on location input.
     * @param longitude Longitude of Location
     * @param latitude Latitude of Location
     */
    public getFireRiskByLocation (longitude: string, latitude: string) : Promise<{ response: http.IncomingMessage; body: FireRiskLocationResponse;  }> {
        const localVarPath = this.basePath + '/georisk/v1/fire/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter longitude was null or undefined when calling getFireRiskByLocation."}]}})
        }

        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter latitude was null or undefined when calling getFireRiskByLocation."}]}})
        }

        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: FireRiskLocationResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Batch method for getting fire risk by location
     * Batch method for getting fire risk by location
     * @param body 
     */
    public getFireRiskByLocationBatch (body?: FireRiskByLocationRequest) : Promise<{ response: http.IncomingMessage; body: FireRiskLocationResponseList;  }> {
        const localVarPath = this.basePath + '/georisk/v1/fire/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: FireRiskLocationResponseList;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Gets FireStationResponse
     * Returns the nearest Firestations from an input address.
     * @param address The address to be searched.
     * @param maxCandidates Specifies the maximum number of fire stations that this service retrieves. The default value is 3 and maximum value is 5. The retrieved results are traveldistance sorted from the input location.
     * @param travelTime Max travel time from input location to fire station. Maximum allowed is 2 hours
     * @param travelTimeUnit Travel time unit such as minutes (default), hours, seconds or milliseconds.
     * @param travelDistance Maximum travel distance from input location to fire station. Maximum allowed is 50 miles
     * @param travelDistanceUnit Travel distance unit such as Feet (default), Kilometers, Miles or Meters.
     * @param sortBy Sort the fire stations results by either travel time or travel distance (nearest first). Default sorting is by travel time.
     * @param historicTrafficTimeBucket Historic traffic time slab
     */
    public getFireStationByAddress (address: string, maxCandidates?: string, travelTime?: string, travelTimeUnit?: string, travelDistance?: string, travelDistanceUnit?: string, sortBy?: string, historicTrafficTimeBucket?: string) : Promise<{ response: http.IncomingMessage; body: FireStations;  }> {
        const localVarPath = this.basePath + '/georisk/v1/firestation/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter address was null or undefined when calling getFireStationByAddress."}]}})
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        if (maxCandidates !== undefined) {
            queryParameters['maxCandidates'] = maxCandidates;
        }

        if (travelTime !== undefined) {
            queryParameters['travelTime'] = travelTime;
        }

        if (travelTimeUnit !== undefined) {
            queryParameters['travelTimeUnit'] = travelTimeUnit;
        }

        if (travelDistance !== undefined) {
            queryParameters['travelDistance'] = travelDistance;
        }

        if (travelDistanceUnit !== undefined) {
            queryParameters['travelDistanceUnit'] = travelDistanceUnit;
        }

        if (sortBy !== undefined) {
            queryParameters['sortBy'] = sortBy;
        }

        if (historicTrafficTimeBucket !== undefined) {
            queryParameters['historicTrafficTimeBucket'] = historicTrafficTimeBucket;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: FireStations;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Gets FireStationResponse
     * Returns the nearest Firestations from an input location.
     * @param longitude Longitude of Location
     * @param latitude Latitude of Location
     * @param maxCandidates Specifies the maximum number of fire stations that this service retrieves. The default value is 3. The retrieved fire stations are distance ordered from the specified location. Maximum of 5 fire stations can be retrieved.
     * @param travelTime Maximum travel time from input location to fire station. Maximum allowed is 2 hours
     * @param travelTimeUnit Travel time unit such as minutes (default), hours, seconds or milliseconds.
     * @param travelDistance Maximum travel distance from input location to fire station. Maximum allowed is 50 miles
     * @param travelDistanceUnit Travel distance unit such as Feet (default), Kilometers, Miles or Meters.
     * @param sortBy Sorting of fire stations in result by travel time/distance (nearest first from input location).
     * @param historicTrafficTimeBucket Historic traffic time slab
     */
    public getFireStationByLocation (longitude: string, latitude: string, maxCandidates?: string, travelTime?: string, travelTimeUnit?: string, travelDistance?: string, travelDistanceUnit?: string, sortBy?: string, historicTrafficTimeBucket?: string) : Promise<{ response: http.IncomingMessage; body: FireStationsLocation;  }> {
        const localVarPath = this.basePath + '/georisk/v1/firestation/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter longitude was null or undefined when calling getFireStationByLocation."}]}})
        }

        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter latitude was null or undefined when calling getFireStationByLocation."}]}})
        }

        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        if (maxCandidates !== undefined) {
            queryParameters['maxCandidates'] = maxCandidates;
        }

        if (travelTime !== undefined) {
            queryParameters['travelTime'] = travelTime;
        }

        if (travelTimeUnit !== undefined) {
            queryParameters['travelTimeUnit'] = travelTimeUnit;
        }

        if (travelDistance !== undefined) {
            queryParameters['travelDistance'] = travelDistance;
        }

        if (travelDistanceUnit !== undefined) {
            queryParameters['travelDistanceUnit'] = travelDistanceUnit;
        }

        if (sortBy !== undefined) {
            queryParameters['sortBy'] = sortBy;
        }

        if (historicTrafficTimeBucket !== undefined) {
            queryParameters['historicTrafficTimeBucket'] = historicTrafficTimeBucket;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: FireStationsLocation;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Gets FloodRiskResponse
     * Returns the Flood Risk data for flood zones based on an address.
     * @param address Free-text Address
     * @param includeZoneDesc Specifies primary zone description. Valid Values: &#39;Y&#39; or &#39;N&#39;.
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response
     */
    public getFloodRiskByAddress (address: string, includeZoneDesc?: string, includeGeometry?: string) : Promise<{ response: http.IncomingMessage; body: FloodRiskResponse;  }> {
        const localVarPath = this.basePath + '/georisk/v1/flood/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter address was null or undefined when calling getFloodRiskByAddress."}]}})
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        if (includeZoneDesc !== undefined) {
            queryParameters['includeZoneDesc'] = includeZoneDesc;
        }

        if (includeGeometry !== undefined) {
            queryParameters['includeGeometry'] = includeGeometry;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: FloodRiskResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Batch method for getting flood risk by address
     * Batch method for getting flood risk by address
     * @param body 
     */
    public getFloodRiskByAddressBatch (body?: FloodRiskByAddressRequest) : Promise<{ response: http.IncomingMessage; body: FloodRiskResponseList;  }> {
        const localVarPath = this.basePath + '/georisk/v1/flood/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: FloodRiskResponseList;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Gets FloodRiskResponse
     * Returns the Flood Risk data for Flood Zones and Base Flood Elevation, based on location.
     * @param longitude Longitude of Location
     * @param latitude Latitude of Location
     * @param includeZoneDesc Specifies primary zone description. Valid Values: &#39;Y&#39; or &#39;N&#39;. Default: &#39;Y&#39;
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response
     */
    public getFloodRiskByLocation (longitude: string, latitude: string, includeZoneDesc?: string, includeGeometry?: string) : Promise<{ response: http.IncomingMessage; body: FloodRiskLocationResponse;  }> {
        const localVarPath = this.basePath + '/georisk/v1/flood/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter longitude was null or undefined when calling getFloodRiskByLocation."}]}})
        }

        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter latitude was null or undefined when calling getFloodRiskByLocation."}]}})
        }

        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        if (includeZoneDesc !== undefined) {
            queryParameters['includeZoneDesc'] = includeZoneDesc;
        }

        if (includeGeometry !== undefined) {
            queryParameters['includeGeometry'] = includeGeometry;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: FloodRiskLocationResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Batch method for getting flood risk by location
     * Batch method for getting flood risk by location
     * @param body 
     */
    public getFloodRiskByLocationBatch (body?: FloodRiskByLocationRequest) : Promise<{ response: http.IncomingMessage; body: FloodRiskLocationResponseList;  }> {
        const localVarPath = this.basePath + '/georisk/v1/flood/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: FloodRiskLocationResponseList;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
}
export enum LIAPIGeoRouteServiceApiApiKeys {
}

export class LIAPIGeoRouteServiceApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications : OAuth;
    protected  oAuthCred : oAuthCredInfo;

    /*protected authentications = {
       // 'default': <Authentication>new VoidAuth(),
        'oAuth2Password': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }*/

    constructor(oAuthObj: oAuthCredInfo);
    constructor(oAuthObj: oAuthCredInfo,basePath?: string)
    {
    if(oAuthObj)
    {
    this.oAuthCred=oAuthObj;
    }
    if (basePath) {
    this.basePath = basePath;
    }
    }
    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: LIAPIGeoRouteServiceApiApiKeys, value: string) {
        this.authentications[LIAPIGeoRouteServiceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.objOAuthCredInfo.access_token = token;
    }
    
    /**
     * Gets Route by Address
     * Routing Directions for Single and Multiple Origin &amp; Destination Inputs. Accepts addresses as input and Returns Point-to-Point and Multi-Point travel directions by various travel modes.
     * @param startAddress Starting address of the route.
     * @param endAddress Ending address of the route.
     * @param db Mode of commute.
     * @param country Three digit ISO country code
     * @param intermediateAddresses List of intermediate addresses of the route.
     * @param oip Specifies whether waypoints need to be optimized.
     * @param destinationSrs Specifies the desired coordinate system of the returned route.
     * @param optimizeBy Specifies whether the route should be optimized by time or distance.
     * @param returnDistance Specifies whether distance needs to be part of direction information in response.
     * @param distanceUnit Return Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard).
     * @param returnTime Specifies whether time needs to be part of direction information in response.
     * @param timeUnit Return time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond).
     * @param language Language of travel directions.
     * @param directionsStyle Specifies whether route directions text is to be returned in the response and in what detail (Normal or Terse).
     * @param segmentGeometryStyle Specifies whether the route geometry is to be returned in the response and in what detail (End or All).
     * @param primaryNameOnly If true then only the primary street name is returned otherwise all the names for a street.
     * @param majorRoads Whether to include all roads in route calculation or just major roads.
     * @param historicTrafficTimeBucket Specifies whether routing calculation uses the historic traffic speeds.
     * @param returnDirectionGeometry Whether to include geometry associated with each route instruction in response.
     */
    public getRouteByAddress (startAddress: string, endAddress: string, db?: string, country?: string, intermediateAddresses?: string, oip?: string, destinationSrs?: string, optimizeBy?: string, returnDistance?: string, distanceUnit?: string, returnTime?: string, timeUnit?: string, language?: string, directionsStyle?: string, segmentGeometryStyle?: string, primaryNameOnly?: string, majorRoads?: string, historicTrafficTimeBucket?: string, returnDirectionGeometry?: string) : Promise<{ response: http.IncomingMessage; body: GeoRouteResponse;  }> {
        const localVarPath = this.basePath + '/georoute/v1/route/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'startAddress' is not null or undefined
        if (startAddress === null || startAddress === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter startAddress was null or undefined when calling getRouteByAddress."}]}})
        }

        // verify required parameter 'endAddress' is not null or undefined
        if (endAddress === null || endAddress === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter endAddress was null or undefined when calling getRouteByAddress."}]}})
        }

        if (startAddress !== undefined) {
            queryParameters['startAddress'] = startAddress;
        }

        if (endAddress !== undefined) {
            queryParameters['endAddress'] = endAddress;
        }

        if (db !== undefined) {
            queryParameters['db'] = db;
        }

        if (country !== undefined) {
            queryParameters['country'] = country;
        }

        if (intermediateAddresses !== undefined) {
            queryParameters['intermediateAddresses'] = intermediateAddresses;
        }

        if (oip !== undefined) {
            queryParameters['oip'] = oip;
        }

        if (destinationSrs !== undefined) {
            queryParameters['destinationSrs'] = destinationSrs;
        }

        if (optimizeBy !== undefined) {
            queryParameters['optimizeBy'] = optimizeBy;
        }

        if (returnDistance !== undefined) {
            queryParameters['returnDistance'] = returnDistance;
        }

        if (distanceUnit !== undefined) {
            queryParameters['distanceUnit'] = distanceUnit;
        }

        if (returnTime !== undefined) {
            queryParameters['returnTime'] = returnTime;
        }

        if (timeUnit !== undefined) {
            queryParameters['timeUnit'] = timeUnit;
        }

        if (language !== undefined) {
            queryParameters['language'] = language;
        }

        if (directionsStyle !== undefined) {
            queryParameters['directionsStyle'] = directionsStyle;
        }

        if (segmentGeometryStyle !== undefined) {
            queryParameters['segmentGeometryStyle'] = segmentGeometryStyle;
        }

        if (primaryNameOnly !== undefined) {
            queryParameters['primaryNameOnly'] = primaryNameOnly;
        }

        if (majorRoads !== undefined) {
            queryParameters['majorRoads'] = majorRoads;
        }

        if (historicTrafficTimeBucket !== undefined) {
            queryParameters['historicTrafficTimeBucket'] = historicTrafficTimeBucket;
        }

        if (returnDirectionGeometry !== undefined) {
            queryParameters['returnDirectionGeometry'] = returnDirectionGeometry;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: GeoRouteResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Gets Route by Location
     * Returns the fastest or shortest route based on a starting and ending location with optional intermediate points as input.
     * @param startPoint Start Point in &#39;Lat,Long,coordsys&#39; format
     * @param endPoint End Point in &#39;Lat,Long,coordsys&#39; format
     * @param db Mode of commute.
     * @param intermediatePoints List of intermediate points of the route.
     * @param oip Specifies whether waypoints need to be optimized.
     * @param destinationSrs Specifies the desired coordinate system of the returned route.
     * @param optimizeBy Specifies whether the route should be optimized by time or distance.
     * @param returnDistance Specifies whether distance needs to be part of direction information in response.
     * @param distanceUnit Return Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard).
     * @param returnTime Specifies whether time needs to be part of direction information in response.
     * @param timeUnit Return time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond).
     * @param language Specifies the language of travel directions.
     * @param directionsStyle Specifies whether route directions text is to be returned in the response and in what detail (Normal or Terse).
     * @param segmentGeometryStyle Specifies whether the route geometry is to be returned in the response and in what detail (End or All).
     * @param primaryNameOnly If true then only the primary street name is returned otherwise all the names for a street.
     * @param majorRoads Whether to include all roads in route calculation or just major roads.
     * @param historicTrafficTimeBucket Specifies whether routing calculation uses the historic traffic speeds.
     * @param returnDirectionGeometry Whether to include geometry associated with each route instruction in response.
     */
    public getRouteByLocation (startPoint: string, endPoint: string, db?: string, intermediatePoints?: string, oip?: string, destinationSrs?: string, optimizeBy?: string, returnDistance?: string, distanceUnit?: string, returnTime?: string, timeUnit?: string, language?: string, directionsStyle?: string, segmentGeometryStyle?: string, primaryNameOnly?: string, majorRoads?: string, historicTrafficTimeBucket?: string, returnDirectionGeometry?: string) : Promise<{ response: http.IncomingMessage; body: GeoRouteResponse;  }> {
        const localVarPath = this.basePath + '/georoute/v1/route/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'startPoint' is not null or undefined
        if (startPoint === null || startPoint === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter startPoint was null or undefined when calling getRouteByLocation."}]}})
        }

        // verify required parameter 'endPoint' is not null or undefined
        if (endPoint === null || endPoint === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter endPoint was null or undefined when calling getRouteByLocation."}]}})
        }

        if (startPoint !== undefined) {
            queryParameters['startPoint'] = startPoint;
        }

        if (endPoint !== undefined) {
            queryParameters['endPoint'] = endPoint;
        }

        if (db !== undefined) {
            queryParameters['db'] = db;
        }

        if (intermediatePoints !== undefined) {
            queryParameters['intermediatePoints'] = intermediatePoints;
        }

        if (oip !== undefined) {
            queryParameters['oip'] = oip;
        }

        if (destinationSrs !== undefined) {
            queryParameters['destinationSrs'] = destinationSrs;
        }

        if (optimizeBy !== undefined) {
            queryParameters['optimizeBy'] = optimizeBy;
        }

        if (returnDistance !== undefined) {
            queryParameters['returnDistance'] = returnDistance;
        }

        if (distanceUnit !== undefined) {
            queryParameters['distanceUnit'] = distanceUnit;
        }

        if (returnTime !== undefined) {
            queryParameters['returnTime'] = returnTime;
        }

        if (timeUnit !== undefined) {
            queryParameters['timeUnit'] = timeUnit;
        }

        if (language !== undefined) {
            queryParameters['language'] = language;
        }

        if (directionsStyle !== undefined) {
            queryParameters['directionsStyle'] = directionsStyle;
        }

        if (segmentGeometryStyle !== undefined) {
            queryParameters['segmentGeometryStyle'] = segmentGeometryStyle;
        }

        if (primaryNameOnly !== undefined) {
            queryParameters['primaryNameOnly'] = primaryNameOnly;
        }

        if (majorRoads !== undefined) {
            queryParameters['majorRoads'] = majorRoads;
        }

        if (historicTrafficTimeBucket !== undefined) {
            queryParameters['historicTrafficTimeBucket'] = historicTrafficTimeBucket;
        }

        if (returnDirectionGeometry !== undefined) {
            queryParameters['returnDirectionGeometry'] = returnDirectionGeometry;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: GeoRouteResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Gets Cost Matrix by Address
     * Calculates the travel time and distances between an array of start and end addresses.
     * @param startAddresses Start locations in text based addresses.
     * @param endAddresses End locations in text based addresses.
     * @param db Mode of commute.
     * @param country 3 Digit ISO country code.
     * @param optimizeBy Specifies the type of optimizing to use for the route (time/distance).
     * @param returnDistance Specifies whether to return the travel distance in the response or not.
     * @param destinationSrs Coordinate system used for the returned routes.
     * @param distanceUnit Return Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard).
     * @param returnTime Specifies whether to return the travel time in the response or not.
     * @param timeUnit Return time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond).
     * @param majorRoads Whether to include all roads in routes calculation or just major roads.
     * @param returnOptimalRoutesOnly Specifies whether to return only the optimized route for each start and end point combination.
     * @param historicTrafficTimeBucket Specifies whether routing calculation uses the historic traffic speeds.
     */
    public getTravelCostMatrixByAddress (startAddresses: string, endAddresses: string, db?: string, country?: string, optimizeBy?: string, returnDistance?: string, destinationSrs?: string, distanceUnit?: string, returnTime?: string, timeUnit?: string, majorRoads?: string, returnOptimalRoutesOnly?: string, historicTrafficTimeBucket?: string) : Promise<{ response: http.IncomingMessage; body: TravelCostMatrixResponse;  }> {
        const localVarPath = this.basePath + '/georoute/v1/travelcostmatrix/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'startAddresses' is not null or undefined
        if (startAddresses === null || startAddresses === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter startAddresses was null or undefined when calling getTravelCostMatrixByAddress."}]}})
        }

        // verify required parameter 'endAddresses' is not null or undefined
        if (endAddresses === null || endAddresses === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter endAddresses was null or undefined when calling getTravelCostMatrixByAddress."}]}})
        }

        if (startAddresses !== undefined) {
            queryParameters['startAddresses'] = startAddresses;
        }

        if (endAddresses !== undefined) {
            queryParameters['endAddresses'] = endAddresses;
        }

        if (db !== undefined) {
            queryParameters['db'] = db;
        }

        if (country !== undefined) {
            queryParameters['country'] = country;
        }

        if (optimizeBy !== undefined) {
            queryParameters['optimizeBy'] = optimizeBy;
        }

        if (returnDistance !== undefined) {
            queryParameters['returnDistance'] = returnDistance;
        }

        if (destinationSrs !== undefined) {
            queryParameters['destinationSrs'] = destinationSrs;
        }

        if (distanceUnit !== undefined) {
            queryParameters['distanceUnit'] = distanceUnit;
        }

        if (returnTime !== undefined) {
            queryParameters['returnTime'] = returnTime;
        }

        if (timeUnit !== undefined) {
            queryParameters['timeUnit'] = timeUnit;
        }

        if (majorRoads !== undefined) {
            queryParameters['majorRoads'] = majorRoads;
        }

        if (returnOptimalRoutesOnly !== undefined) {
            queryParameters['returnOptimalRoutesOnly'] = returnOptimalRoutesOnly;
        }

        if (historicTrafficTimeBucket !== undefined) {
            queryParameters['historicTrafficTimeBucket'] = historicTrafficTimeBucket;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: TravelCostMatrixResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Gets Cost Matrix by Location
     * GeoRoute&#39;s &#39;Travel Cost Matrix By Location&#39; service calculates the travel time and distances between an array of start and end points based on location coordinates.
     * @param startPoints The address to be searched.
     * @param endPoints The address to be searched.
     * @param db Mode of commute.
     * @param optimizeBy Specifies whether routes should be optimized by time or distance.
     * @param returnDistance Specifies whether distance needs to be returned in response.
     * @param destinationSrs Specifies the desired coordinate system of returned routes.
     * @param distanceUnit Return Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard).
     * @param returnTime Specifies whether time needs to be returned in response.
     * @param timeUnit Return time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond).
     * @param majorRoads Whether to include all roads in routes calculation or just major roads.
     * @param returnOptimalRoutesOnly Specifies whether to return only the optimized route for each start and end point combination.
     * @param historicTrafficTimeBucket Specifies whether routing calculation uses the historic traffic speeds.
     */
    public getTravelCostMatrixByLocation (startPoints: string, endPoints: string, db?: string, optimizeBy?: string, returnDistance?: string, destinationSrs?: string, distanceUnit?: string, returnTime?: string, timeUnit?: string, majorRoads?: string, returnOptimalRoutesOnly?: string, historicTrafficTimeBucket?: string) : Promise<{ response: http.IncomingMessage; body: TravelCostMatrixResponse;  }> {
        const localVarPath = this.basePath + '/georoute/v1/travelcostmatrix/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'startPoints' is not null or undefined
        if (startPoints === null || startPoints === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter startPoints was null or undefined when calling getTravelCostMatrixByLocation."}]}})
        }

        // verify required parameter 'endPoints' is not null or undefined
        if (endPoints === null || endPoints === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter endPoints was null or undefined when calling getTravelCostMatrixByLocation."}]}})
        }

        if (startPoints !== undefined) {
            queryParameters['startPoints'] = startPoints;
        }

        if (endPoints !== undefined) {
            queryParameters['endPoints'] = endPoints;
        }

        if (db !== undefined) {
            queryParameters['db'] = db;
        }

        if (optimizeBy !== undefined) {
            queryParameters['optimizeBy'] = optimizeBy;
        }

        if (returnDistance !== undefined) {
            queryParameters['returnDistance'] = returnDistance;
        }

        if (destinationSrs !== undefined) {
            queryParameters['destinationSrs'] = destinationSrs;
        }

        if (distanceUnit !== undefined) {
            queryParameters['distanceUnit'] = distanceUnit;
        }

        if (returnTime !== undefined) {
            queryParameters['returnTime'] = returnTime;
        }

        if (timeUnit !== undefined) {
            queryParameters['timeUnit'] = timeUnit;
        }

        if (majorRoads !== undefined) {
            queryParameters['majorRoads'] = majorRoads;
        }

        if (returnOptimalRoutesOnly !== undefined) {
            queryParameters['returnOptimalRoutesOnly'] = returnOptimalRoutesOnly;
        }

        if (historicTrafficTimeBucket !== undefined) {
            queryParameters['historicTrafficTimeBucket'] = historicTrafficTimeBucket;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: TravelCostMatrixResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
}
export enum LIAPIGeoSearchServiceApiApiKeys {
}

export class LIAPIGeoSearchServiceApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications : OAuth;
    protected  oAuthCred : oAuthCredInfo;

    /*protected authentications = {
       // 'default': <Authentication>new VoidAuth(),
        'oAuth2Password': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }*/

    constructor(oAuthObj: oAuthCredInfo);
    constructor(oAuthObj: oAuthCredInfo,basePath?: string)
    {
    if(oAuthObj)
    {
    this.oAuthCred=oAuthObj;
    }
    if (basePath) {
    this.basePath = basePath;
    }
    }
    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: LIAPIGeoSearchServiceApiApiKeys, value: string) {
        this.authentications[LIAPIGeoSearchServiceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.objOAuthCredInfo.access_token = token;
    }
    
    /**
     * Gets LocationList
     * Gets LocationList
     * @param searchText The input to be searched.
     * @param latitude Latitude of the location. Either the latitude or the longitude must be provided.
     * @param longitude Longitude of the location. Either the latitude or the longitude must be provided.
     * @param searchRadius Radius range within which search is performed.
     * @param searchRadiusUnit Radius unit such as Feet, Kilometers, Miles or Meters.
     * @param maxCandidates Maximum number of addresses that can be retrieved.
     * @param country Country ISO code. We need to make sure that either Lat/Lng or Country is provided to API
     * @param matchOnAddressNumber Option so that we force api to match on address number
     * @param autoDetectLocation Option to allow API to detect origin of API request automatically
     * @param ipAddress 
     * @param areaName1 State province of the input to be searched
     * @param areaName3 City of the input to be searched
     * @param postCode Postal Code of the input to be searched
     * @param returnAdminAreasOnly if value set &#39;Y&#39; then it will only do a matching on postcode or areaName1, areaName2, areaName3 and areaName4 fields in the data
     * @param includeRangesDetails if value set &#39;Y&#39; then display all unit info of ranges, if value set &#39;N&#39; then don&#39;t show ranges
     * @param searchType Preference to control search type of interactive requests.
     */
    public geoSearch (searchText: string, latitude?: string, longitude?: string, searchRadius?: string, searchRadiusUnit?: string, maxCandidates?: string, country?: string, matchOnAddressNumber?: string, autoDetectLocation?: string, ipAddress?: string, areaName1?: string, areaName3?: string, postCode?: string, returnAdminAreasOnly?: string, includeRangesDetails?: string, searchType?: string) : Promise<{ response: http.IncomingMessage; body: GeosearchLocations;  }> {
        const localVarPath = this.basePath + '/geosearch/v2/locations';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'searchText' is not null or undefined
        if (searchText === null || searchText === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter searchText was null or undefined when calling geoSearch."}]}})
        }

        if (searchText !== undefined) {
            queryParameters['searchText'] = searchText;
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        if (searchRadius !== undefined) {
            queryParameters['searchRadius'] = searchRadius;
        }

        if (searchRadiusUnit !== undefined) {
            queryParameters['searchRadiusUnit'] = searchRadiusUnit;
        }

        if (maxCandidates !== undefined) {
            queryParameters['maxCandidates'] = maxCandidates;
        }

        if (country !== undefined) {
            queryParameters['country'] = country;
        }

        if (matchOnAddressNumber !== undefined) {
            queryParameters['matchOnAddressNumber'] = matchOnAddressNumber;
        }

        if (autoDetectLocation !== undefined) {
            queryParameters['autoDetectLocation'] = autoDetectLocation;
        }

        if (ipAddress !== undefined) {
            queryParameters['ipAddress'] = ipAddress;
        }

        if (areaName1 !== undefined) {
            queryParameters['areaName1'] = areaName1;
        }

        if (areaName3 !== undefined) {
            queryParameters['areaName3'] = areaName3;
        }

        if (postCode !== undefined) {
            queryParameters['postCode'] = postCode;
        }

        if (returnAdminAreasOnly !== undefined) {
            queryParameters['returnAdminAreasOnly'] = returnAdminAreasOnly;
        }

        if (includeRangesDetails !== undefined) {
            queryParameters['includeRangesDetails'] = includeRangesDetails;
        }

        if (searchType !== undefined) {
            queryParameters['searchType'] = searchType;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: GeosearchLocations;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
}
export enum LIAPIGeoTaxServiceApiApiKeys {
}

export class LIAPIGeoTaxServiceApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications : OAuth;
    protected  oAuthCred : oAuthCredInfo;

    /*protected authentications = {
       // 'default': <Authentication>new VoidAuth(),
        'oAuth2Password': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }*/

    constructor(oAuthObj: oAuthCredInfo);
    constructor(oAuthObj: oAuthCredInfo,basePath?: string)
    {
    if(oAuthObj)
    {
    this.oAuthCred=oAuthObj;
    }
    if (basePath) {
    this.basePath = basePath;
    }
    }
    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: LIAPIGeoTaxServiceApiApiKeys, value: string) {
        this.authentications[LIAPIGeoTaxServiceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.objOAuthCredInfo.access_token = token;
    }
    
    /**
     * Post Tax By Address
     * This is a Batch offering for &#39;Tax By Address&#39; service. It accepts a single address, purchase amount or a list of addresses, purchase amounts and retrieve applicable taxes.
     * @param taxRateTypeId The tax rate id.
     * @param body TaxAddressRequest Class Object having tax request.
     */
    public getBatchTaxByAddress (taxRateTypeId: string, body: TaxAddressRequest) : Promise<{ response: http.IncomingMessage; body: TaxResponses;  }> {
        const localVarPath = this.basePath + '/geotax/v1/tax/{taxRateTypeId}/byaddress'
            .replace('{' + 'taxRateTypeId' + '}', String(taxRateTypeId));
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'taxRateTypeId' is not null or undefined
        if (taxRateTypeId === null || taxRateTypeId === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter taxRateTypeId was null or undefined when calling getBatchTaxByAddress."}]}})
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter body was null or undefined when calling getBatchTaxByAddress."}]}})
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: TaxResponses;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Post Tax By Location
     * This is a Batch offering for &#39;Tax By Location&#39; service. It accepts a single location coordinate, purchase amount or a list of location coordinates, purchase amounts and retrieve applicable tax.
     * @param taxRateTypeId The tax rate id.
     * @param body TaxAddressRequest Class Object having tax request.
     */
    public getBatchTaxByLocation (taxRateTypeId: string, body: TaxLocationRequest) : Promise<{ response: http.IncomingMessage; body: TaxLocationResponses;  }> {
        const localVarPath = this.basePath + '/geotax/v1/tax/{taxRateTypeId}/bylocation'
            .replace('{' + 'taxRateTypeId' + '}', String(taxRateTypeId));
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'taxRateTypeId' is not null or undefined
        if (taxRateTypeId === null || taxRateTypeId === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter taxRateTypeId was null or undefined when calling getBatchTaxByLocation."}]}})
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter body was null or undefined when calling getBatchTaxByLocation."}]}})
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: TaxLocationResponses;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Post Taxrate By Address
     * This is a Batch offering for &#39;Taxrate By Address&#39; service. It accepts a single address or a list of addresses and retrieve applicable tax rates.
     * @param taxRateTypeId The tax rate id.
     * @param body TaxRateAddressRequest Class Object having tax rate request.
     */
    public getBatchTaxRateByAddress (taxRateTypeId: string, body: TaxRateAddressRequest) : Promise<{ response: http.IncomingMessage; body: TaxRateResponses;  }> {
        const localVarPath = this.basePath + '/geotax/v1/taxrate/{taxRateTypeId}/byaddress'
            .replace('{' + 'taxRateTypeId' + '}', String(taxRateTypeId));
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'taxRateTypeId' is not null or undefined
        if (taxRateTypeId === null || taxRateTypeId === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter taxRateTypeId was null or undefined when calling getBatchTaxRateByAddress."}]}})
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter body was null or undefined when calling getBatchTaxRateByAddress."}]}})
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: TaxRateResponses;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Post Taxrate By Location
     * This is a Batch offering for &#39;Taxrate By Location&#39; service. It accepts a single location coordinate or a list of location coordinates and retrieve applicable tax rates.
     * @param taxRateTypeId The tax rate id.
     * @param body TaxRateLocationRequest Class Object having tax rate request.
     */
    public getBatchTaxRateByLocation (taxRateTypeId: string, body: TaxRateLocationRequest) : Promise<{ response: http.IncomingMessage; body: TaxRateLocationResponses;  }> {
        const localVarPath = this.basePath + '/geotax/v1/taxrate/{taxRateTypeId}/bylocation'
            .replace('{' + 'taxRateTypeId' + '}', String(taxRateTypeId));
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'taxRateTypeId' is not null or undefined
        if (taxRateTypeId === null || taxRateTypeId === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter taxRateTypeId was null or undefined when calling getBatchTaxRateByLocation."}]}})
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter body was null or undefined when calling getBatchTaxRateByLocation."}]}})
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: TaxRateLocationResponses;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Get IPD Tax by Address
     * This will accept &#39;address&#39; as a parameter and will return one or many IPDs details for that region in which address will fall.
     * @param address The address to be searched.
     * @param returnLatLongFields Y or N (default is N) - Returns Latitude Longitude Fields
     * @param latLongFormat (default is Decimal) - Returns Desired Latitude Longitude Format
     */
    public getIPDTaxByAddress (address: string, returnLatLongFields?: string, latLongFormat?: string) : Promise<{ response: http.IncomingMessage; body: TaxDistrictResponse;  }> {
        const localVarPath = this.basePath + '/geotax/v1/taxdistrict/ipd/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter address was null or undefined when calling getIPDTaxByAddress."}]}})
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        if (returnLatLongFields !== undefined) {
            queryParameters['returnLatLongFields'] = returnLatLongFields;
        }

        if (latLongFormat !== undefined) {
            queryParameters['latLongFormat'] = latLongFormat;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: TaxDistrictResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Get IPD Tax for batch requests
     * Get IPD Tax for batch requests
     * @param body IPDTaxByAddressBatchRequest Class Object having IPD tax request
     */
    public getIPDTaxByAddressBatch (body: IPDTaxByAddressBatchRequest) : Promise<{ response: http.IncomingMessage; body: TaxDistrictResponseList;  }> {
        const localVarPath = this.basePath + '/geotax/v1/taxdistrict/ipd/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter body was null or undefined when calling getIPDTaxByAddressBatch."}]}})
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: TaxDistrictResponseList;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Get Tax By Address
     * This service calculates and returns taxes applicable at a specific address. Address, purchase amount and supported tax rate type are inputs to the service.
     * @param taxRateTypeId The tax rate id.
     * @param address The address to be searched.
     * @param purchaseAmount The amount on which tax to be calculated.
     */
    public getSpecificTaxByAddress (taxRateTypeId: string, address: string, purchaseAmount: string) : Promise<{ response: http.IncomingMessage; body: TaxResponse;  }> {
        const localVarPath = this.basePath + '/geotax/v1/tax/{taxRateTypeId}/byaddress'
            .replace('{' + 'taxRateTypeId' + '}', String(taxRateTypeId));
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'taxRateTypeId' is not null or undefined
        if (taxRateTypeId === null || taxRateTypeId === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter taxRateTypeId was null or undefined when calling getSpecificTaxByAddress."}]}})
        }

        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter address was null or undefined when calling getSpecificTaxByAddress."}]}})
        }

        // verify required parameter 'purchaseAmount' is not null or undefined
        if (purchaseAmount === null || purchaseAmount === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter purchaseAmount was null or undefined when calling getSpecificTaxByAddress."}]}})
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        if (purchaseAmount !== undefined) {
            queryParameters['purchaseAmount'] = purchaseAmount;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: TaxResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Get Tax By Location
     * This service calculates and returns tax applicable at a specific location. Longitude, latitude, purchase amount and supported tax rate type are inputs to the service.
     * @param taxRateTypeId The tax rate id.
     * @param latitude Latitude of the location.
     * @param longitude Longitude of the location.
     * @param purchaseAmount The amount on which tax to be calculated.
     */
    public getSpecificTaxByLocation (taxRateTypeId: string, latitude: string, longitude: string, purchaseAmount: string) : Promise<{ response: http.IncomingMessage; body: TaxResponse;  }> {
        const localVarPath = this.basePath + '/geotax/v1/tax/{taxRateTypeId}/bylocation'
            .replace('{' + 'taxRateTypeId' + '}', String(taxRateTypeId));
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'taxRateTypeId' is not null or undefined
        if (taxRateTypeId === null || taxRateTypeId === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter taxRateTypeId was null or undefined when calling getSpecificTaxByLocation."}]}})
        }

        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter latitude was null or undefined when calling getSpecificTaxByLocation."}]}})
        }

        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter longitude was null or undefined when calling getSpecificTaxByLocation."}]}})
        }

        // verify required parameter 'purchaseAmount' is not null or undefined
        if (purchaseAmount === null || purchaseAmount === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter purchaseAmount was null or undefined when calling getSpecificTaxByLocation."}]}})
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        if (purchaseAmount !== undefined) {
            queryParameters['purchaseAmount'] = purchaseAmount;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: TaxResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Get Taxrate By Address
     * Retrieves tax rates applicable to a specific address. This service accepts address and supported tax rate type as inputs to retrieve applicable tax rates.
     * @param taxRateTypeId The tax rate id.
     * @param address The address to be searched.
     */
    public getSpecificTaxRateByAddress (taxRateTypeId: string, address: string) : Promise<{ response: http.IncomingMessage; body: TaxRateResponse;  }> {
        const localVarPath = this.basePath + '/geotax/v1/taxrate/{taxRateTypeId}/byaddress'
            .replace('{' + 'taxRateTypeId' + '}', String(taxRateTypeId));
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'taxRateTypeId' is not null or undefined
        if (taxRateTypeId === null || taxRateTypeId === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter taxRateTypeId was null or undefined when calling getSpecificTaxRateByAddress."}]}})
        }

        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter address was null or undefined when calling getSpecificTaxRateByAddress."}]}})
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: TaxRateResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Get Taxrate By Location
     * Retrieves tax rates applicable to a specific location. This service accepts longitude, latitude and supported tax rate type as inputs to retrieve applicable tax rates.
     * @param taxRateTypeId The tax rate id.
     * @param latitude Latitude of the location.
     * @param longitude Longitude of the location.
     */
    public getSpecificTaxRateByLocation (taxRateTypeId: string, latitude: string, longitude: string) : Promise<{ response: http.IncomingMessage; body: TaxRateResponse;  }> {
        const localVarPath = this.basePath + '/geotax/v1/taxrate/{taxRateTypeId}/bylocation'
            .replace('{' + 'taxRateTypeId' + '}', String(taxRateTypeId));
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'taxRateTypeId' is not null or undefined
        if (taxRateTypeId === null || taxRateTypeId === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter taxRateTypeId was null or undefined when calling getSpecificTaxRateByLocation."}]}})
        }

        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter latitude was null or undefined when calling getSpecificTaxRateByLocation."}]}})
        }

        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter longitude was null or undefined when calling getSpecificTaxRateByLocation."}]}})
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: TaxRateResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
}
export enum LIAPIGeoTimeServiceApiApiKeys {
}

export class LIAPIGeoTimeServiceApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications : OAuth;
    protected  oAuthCred : oAuthCredInfo;

    /*protected authentications = {
       // 'default': <Authentication>new VoidAuth(),
        'oAuth2Password': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }*/

    constructor(oAuthObj: oAuthCredInfo);
    constructor(oAuthObj: oAuthCredInfo,basePath?: string)
    {
    if(oAuthObj)
    {
    this.oAuthCred=oAuthObj;
    }
    if (basePath) {
    this.basePath = basePath;
    }
    }
    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: LIAPIGeoTimeServiceApiApiKeys, value: string) {
        this.authentications[LIAPIGeoTimeServiceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.objOAuthCredInfo.access_token = token;
    }
    
    /**
     * Timezone By Address.
     * Identifies and retrieves the local time of any location in the world for a given address and time. The input and retrieved time format is in milliseconds.
     * @param timestamp Timestamp in miliseconds.
     * @param address The address to be searched.
     * @param matchMode Match modes determine the leniency used to make a match between the input address and the reference data.
     * @param country Country ISO code.
     */
    public getTimezoneByAddress (timestamp: string, address: string, matchMode?: string, country?: string) : Promise<{ response: http.IncomingMessage; body: Timezone;  }> {
        const localVarPath = this.basePath + '/geotime/v1/timezone/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'timestamp' is not null or undefined
        if (timestamp === null || timestamp === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter timestamp was null or undefined when calling getTimezoneByAddress."}]}})
        }

        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter address was null or undefined when calling getTimezoneByAddress."}]}})
        }

        if (timestamp !== undefined) {
            queryParameters['timestamp'] = timestamp;
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        if (matchMode !== undefined) {
            queryParameters['matchMode'] = matchMode;
        }

        if (country !== undefined) {
            queryParameters['country'] = country;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: Timezone;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Timezone By Location.
     * Identifies and retrieves the local time of any location in the world for a given latitude, longitude and time. The input and retrieved time format is in milliseconds.
     * @param timestamp Timestamp in miliseconds.
     * @param longitude Longitude of the location.
     * @param latitude Latitude of the location.
     */
    public getTimezoneByLocation (timestamp: string, longitude: string, latitude: string) : Promise<{ response: http.IncomingMessage; body: TimezoneLocation;  }> {
        const localVarPath = this.basePath + '/geotime/v1/timezone/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'timestamp' is not null or undefined
        if (timestamp === null || timestamp === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter timestamp was null or undefined when calling getTimezoneByLocation."}]}})
        }

        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter longitude was null or undefined when calling getTimezoneByLocation."}]}})
        }

        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter latitude was null or undefined when calling getTimezoneByLocation."}]}})
        }

        if (timestamp !== undefined) {
            queryParameters['timestamp'] = timestamp;
        }

        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: TimezoneLocation;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
}
export enum LIAPIGeoZoneServiceApiApiKeys {
}

export class LIAPIGeoZoneServiceApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications : OAuth;
    protected  oAuthCred : oAuthCredInfo;

    /*protected authentications = {
       // 'default': <Authentication>new VoidAuth(),
        'oAuth2Password': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }*/

    constructor(oAuthObj: oAuthCredInfo);
    constructor(oAuthObj: oAuthCredInfo,basePath?: string)
    {
    if(oAuthObj)
    {
    this.oAuthCred=oAuthObj;
    }
    if (basePath) {
    this.basePath = basePath;
    }
    }
    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: LIAPIGeoZoneServiceApiApiKeys, value: string) {
        this.authentications[LIAPIGeoZoneServiceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.objOAuthCredInfo.access_token = token;
    }
    
    /**
     * Gets Basic Boundary by Address
     * Gets Basic Boundary by Address
     * @param address Address around which Basic Boundary is requested
     * @param distance This is width of the buffer (in a complete circular buffer, it would be radius of the buffer). This has to be a positive number.
     * @param country Three digit ISO country code
     * @param distanceUnit Longitude around which Basic Boundary is requested
     * @param resolution This is resolution of the buffer. Curves generated in buffer are approximated by line segments and it is measured in segments per circle. The higher the resolution, the smoother the curves of the buffer but more points would be required in the boundary geometry. Number greater than 0 and in multiple of 4. If not in 4, then it is approximated to nearest multiple of 4.
     * @param responseSrs The spatial reference system to express the response in. By default, it would be epsg:4326
     */
    public getBasicBoundaryByAddress (address: string, distance: string, country?: string, distanceUnit?: string, resolution?: string, responseSrs?: string) : Promise<{ response: http.IncomingMessage; body: BasicBoundaryAddress;  }> {
        const localVarPath = this.basePath + '/geozone/v1/basicboundary/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter address was null or undefined when calling getBasicBoundaryByAddress."}]}})
        }

        // verify required parameter 'distance' is not null or undefined
        if (distance === null || distance === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter distance was null or undefined when calling getBasicBoundaryByAddress."}]}})
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        if (country !== undefined) {
            queryParameters['country'] = country;
        }

        if (distance !== undefined) {
            queryParameters['distance'] = distance;
        }

        if (distanceUnit !== undefined) {
            queryParameters['distanceUnit'] = distanceUnit;
        }

        if (resolution !== undefined) {
            queryParameters['resolution'] = resolution;
        }

        if (responseSrs !== undefined) {
            queryParameters['responseSrs'] = responseSrs;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: BasicBoundaryAddress;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Gets Basic Boundary by Location
     * Gets Basic Boundary by Location
     * @param latitude Latitude around which Basic Boundary is requested
     * @param longitude Longitude around which Basic Boundary is requested
     * @param distance This is width of the buffer (in a complete circular buffer, it would be radius of the buffer). This has to be a positive number.
     * @param distanceUnit Longitude around which Basic Boundary is requested
     * @param resolution This is resolution of the buffer. Curves generated in buffer are approximated by line segments and it is measured in segments per circle. The higher the resolution, the smoother the curves of the buffer but more points would be required in the boundary geometry. Number greater than 0 and in multiple of 4. If not in 4, then it is approximated to nearest multiple of 4.
     * @param responseSrs The spatial reference system to express the response in. By default, it would be epsg:4326
     * @param srsName The spatial reference system for input. By default, it would be epsg:4326
     */
    public getBasicBoundaryByLocation (latitude: string, longitude: string, distance: string, distanceUnit?: string, resolution?: string, responseSrs?: string, srsName?: string) : Promise<{ response: http.IncomingMessage; body: BasicBoundary;  }> {
        const localVarPath = this.basePath + '/geozone/v1/basicboundary/bylocation';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter latitude was null or undefined when calling getBasicBoundaryByLocation."}]}})
        }

        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter longitude was null or undefined when calling getBasicBoundaryByLocation."}]}})
        }

        // verify required parameter 'distance' is not null or undefined
        if (distance === null || distance === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter distance was null or undefined when calling getBasicBoundaryByLocation."}]}})
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        if (distance !== undefined) {
            queryParameters['distance'] = distance;
        }

        if (distanceUnit !== undefined) {
            queryParameters['distanceUnit'] = distanceUnit;
        }

        if (resolution !== undefined) {
            queryParameters['resolution'] = resolution;
        }

        if (responseSrs !== undefined) {
            queryParameters['responseSrs'] = responseSrs;
        }

        if (srsName !== undefined) {
            queryParameters['srsName'] = srsName;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: BasicBoundary;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Gets travel Boundary by Distance
     * Returns the travel boundary based on travel distance.
     * @param costs Travel distance(s)
     * @param point Starting point from where the travel boundary is calculated. Point in &#39;Lat,Long,coordsys&#39; format
     * @param address Starting address from where the travel boundary is calculated.
     * @param costUnit Travel distance such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard).
     * @param db Mode of commute.
     * @param country Three digit ISO country code.
     * @param maxOffroadDistance Maximum distance to allow travel off the road network.
     * @param maxOffroadDistanceUnit MaxOffroad Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard).
     * @param destinationSrs Desired coordinate system of the travel boundary.
     * @param majorRoads Whether to include all roads in the calculation or just major roads.
     * @param returnHoles Whether to return holes, which are areas within the larger boundary that cannot be reached within the desired distance.
     * @param returnIslands Whether to return islands, which are small areas outside the main boundary that can be reached within the desired distance.
     * @param simplificationFactor Number between 0.0 and 1.0 where 0.0 is very simple and 1.0 means the most complex.
     * @param bandingStyle Style of banding to be used in the result.
     * @param historicTrafficTimeBucket Whether routing calculation uses the historic traffic speeds.
     * @param defaultAmbientSpeed The speed to travel when going off a network road to find the travel boundary (for all road types).
     * @param ambientSpeedUnit The unit of measure to use to calculate the ambient speed.
     */
    public getTravelBoundaryByDistance (costs: string, point?: string, address?: string, costUnit?: string, db?: string, country?: string, maxOffroadDistance?: string, maxOffroadDistanceUnit?: string, destinationSrs?: string, majorRoads?: string, returnHoles?: string, returnIslands?: string, simplificationFactor?: string, bandingStyle?: string, historicTrafficTimeBucket?: string, defaultAmbientSpeed?: string, ambientSpeedUnit?: string) : Promise<{ response: http.IncomingMessage; body: TravelBoundaries;  }> {
        const localVarPath = this.basePath + '/geozone/v1/travelboundary/bydistance';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'costs' is not null or undefined
        if (costs === null || costs === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter costs was null or undefined when calling getTravelBoundaryByDistance."}]}})
        }

        if (point !== undefined) {
            queryParameters['point'] = point;
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        if (costs !== undefined) {
            queryParameters['costs'] = costs;
        }

        if (costUnit !== undefined) {
            queryParameters['costUnit'] = costUnit;
        }

        if (db !== undefined) {
            queryParameters['db'] = db;
        }

        if (country !== undefined) {
            queryParameters['country'] = country;
        }

        if (maxOffroadDistance !== undefined) {
            queryParameters['maxOffroadDistance'] = maxOffroadDistance;
        }

        if (maxOffroadDistanceUnit !== undefined) {
            queryParameters['maxOffroadDistanceUnit'] = maxOffroadDistanceUnit;
        }

        if (destinationSrs !== undefined) {
            queryParameters['destinationSrs'] = destinationSrs;
        }

        if (majorRoads !== undefined) {
            queryParameters['majorRoads'] = majorRoads;
        }

        if (returnHoles !== undefined) {
            queryParameters['returnHoles'] = returnHoles;
        }

        if (returnIslands !== undefined) {
            queryParameters['returnIslands'] = returnIslands;
        }

        if (simplificationFactor !== undefined) {
            queryParameters['simplificationFactor'] = simplificationFactor;
        }

        if (bandingStyle !== undefined) {
            queryParameters['bandingStyle'] = bandingStyle;
        }

        if (historicTrafficTimeBucket !== undefined) {
            queryParameters['historicTrafficTimeBucket'] = historicTrafficTimeBucket;
        }

        if (defaultAmbientSpeed !== undefined) {
            queryParameters['defaultAmbientSpeed'] = defaultAmbientSpeed;
        }

        if (ambientSpeedUnit !== undefined) {
            queryParameters['ambientSpeedUnit'] = ambientSpeedUnit;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: TravelBoundaries;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Gets travel Boundary by Time
     * Travel boundary based on travel time.
     * @param costs Travel time used to calculate the travel boundary.
     * @param point Starting point from where the travel boundary is calculated. Point in Lat,Long,coordsys format
     * @param address Starting address from where the travel boundary is calculated.
     * @param costUnit Travel time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond).
     * @param db Mode of commute.
     * @param country 3 character ISO code or country name.
     * @param maxOffroadDistance Maximum distance to allow travel off the road network.
     * @param maxOffroadDistanceUnit MaxOffroad Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard).
     * @param destinationSrs Desired coordinate system of the travel boundary.
     * @param majorRoads Whether to include all roads in the calculation or just major roads.
     * @param returnHoles Whether to return holes, which are areas within the larger boundary that cannot be reached within the desired time.
     * @param returnIslands Whether to return islands, which are small areas outside the main boundary that can be reached within the desired time.
     * @param simplificationFactor Number between 0.0 and 1.0 where 0.0 is very simple and 1.0 means the most complex.
     * @param bandingStyle Style of banding to be used in the result.
     * @param historicTrafficTimeBucket Whether routing calculation uses the historic traffic speeds.
     * @param defaultAmbientSpeed The speed to travel when going off a network road to find the travel boundary (for all road types).
     * @param ambientSpeedUnit The unit of measure to use to calculate the ambient speed.
     */
    public getTravelBoundaryByTime (costs: string, point?: string, address?: string, costUnit?: string, db?: string, country?: string, maxOffroadDistance?: string, maxOffroadDistanceUnit?: string, destinationSrs?: string, majorRoads?: string, returnHoles?: string, returnIslands?: string, simplificationFactor?: string, bandingStyle?: string, historicTrafficTimeBucket?: string, defaultAmbientSpeed?: string, ambientSpeedUnit?: string) : Promise<{ response: http.IncomingMessage; body: TravelBoundaries;  }> {
        const localVarPath = this.basePath + '/geozone/v1/travelboundary/bytime';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'costs' is not null or undefined
        if (costs === null || costs === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter costs was null or undefined when calling getTravelBoundaryByTime."}]}})
        }

        if (point !== undefined) {
            queryParameters['point'] = point;
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        if (costs !== undefined) {
            queryParameters['costs'] = costs;
        }

        if (costUnit !== undefined) {
            queryParameters['costUnit'] = costUnit;
        }

        if (db !== undefined) {
            queryParameters['db'] = db;
        }

        if (country !== undefined) {
            queryParameters['country'] = country;
        }

        if (maxOffroadDistance !== undefined) {
            queryParameters['maxOffroadDistance'] = maxOffroadDistance;
        }

        if (maxOffroadDistanceUnit !== undefined) {
            queryParameters['maxOffroadDistanceUnit'] = maxOffroadDistanceUnit;
        }

        if (destinationSrs !== undefined) {
            queryParameters['destinationSrs'] = destinationSrs;
        }

        if (majorRoads !== undefined) {
            queryParameters['majorRoads'] = majorRoads;
        }

        if (returnHoles !== undefined) {
            queryParameters['returnHoles'] = returnHoles;
        }

        if (returnIslands !== undefined) {
            queryParameters['returnIslands'] = returnIslands;
        }

        if (simplificationFactor !== undefined) {
            queryParameters['simplificationFactor'] = simplificationFactor;
        }

        if (bandingStyle !== undefined) {
            queryParameters['bandingStyle'] = bandingStyle;
        }

        if (historicTrafficTimeBucket !== undefined) {
            queryParameters['historicTrafficTimeBucket'] = historicTrafficTimeBucket;
        }

        if (defaultAmbientSpeed !== undefined) {
            queryParameters['defaultAmbientSpeed'] = defaultAmbientSpeed;
        }

        if (ambientSpeedUnit !== undefined) {
            queryParameters['ambientSpeedUnit'] = ambientSpeedUnit;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: TravelBoundaries;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
}
export enum LIAPIGeocodeServiceApiApiKeys {
}

export class LIAPIGeocodeServiceApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications : OAuth;
    protected  oAuthCred : oAuthCredInfo;

    /*protected authentications = {
       // 'default': <Authentication>new VoidAuth(),
        'oAuth2Password': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }*/

    constructor(oAuthObj: oAuthCredInfo);
    constructor(oAuthObj: oAuthCredInfo,basePath?: string)
    {
    if(oAuthObj)
    {
    this.oAuthCred=oAuthObj;
    }
    if (basePath) {
    this.basePath = basePath;
    }
    }
    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: LIAPIGeocodeServiceApiApiKeys, value: string) {
        this.authentications[LIAPIGeocodeServiceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.objOAuthCredInfo.access_token = token;
    }
    
    /**
     * Gets Geocode
     * Gets Geocode
     * @param datapackBundle value of datapackBundle
     * @param country Country name or ISO code.
     * @param placeName Building name, place name, Point of Interest (POI), company or firm name associated with the input address.
     * @param mainAddress Single line input, treated as collection of field elements.
     * @param lastLine The last line of the address.
     * @param areaName1 Specifies the largest geographical area, typically a state or province.
     * @param areaName2 Specifies the secondary geographic area, typically a county or district.
     * @param areaName3 Specifies a city or town name.
     * @param areaName4 Specifies a city subdivision or locality.
     * @param postalCode The postal code in the appropriate format for the country.
     * @param matchMode Match modes determine the leniency used to make a match between the input address and the reference data.
     * @param fallbackGeo Specifies whether to attempt to determine a geographic region centroid when an address-level geocode cannot be determined.
     * @param fallbackPostal Specifies whether to attempt to determine a post code centroid when an address-level geocode cannot be determined.
     * @param maxCands The maximum number of candidates to return.
     * @param streetOffset Indicates the offset distance from the street segments to use in street-level geocoding.
     * @param streetOffsetUnits Specifies the unit of measurement for the street offset.
     * @param cornerOffset Specifies the distance to offset the street end points in street-level matching.
     * @param cornerOffsetUnits Specifies the unit of measurement for the corner offset.
     */
    public geocode (datapackBundle: string, country?: string, placeName?: string, mainAddress?: string, lastLine?: string, areaName1?: string, areaName2?: string, areaName3?: string, areaName4?: string, postalCode?: number, matchMode?: string, fallbackGeo?: boolean, fallbackPostal?: boolean, maxCands?: number, streetOffset?: number, streetOffsetUnits?: string, cornerOffset?: number, cornerOffsetUnits?: string) : Promise<{ response: http.IncomingMessage; body: GeocodeServiceResponse;  }> {
        const localVarPath = this.basePath + '/geocode-service/v1/transient/{datapackBundle}/geocode'
            .replace('{' + 'datapackBundle' + '}', String(datapackBundle));
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'datapackBundle' is not null or undefined
        if (datapackBundle === null || datapackBundle === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter datapackBundle was null or undefined when calling geocode."}]}})
        }

        if (country !== undefined) {
            queryParameters['country'] = country;
        }

        if (placeName !== undefined) {
            queryParameters['placeName'] = placeName;
        }

        if (mainAddress !== undefined) {
            queryParameters['mainAddress'] = mainAddress;
        }

        if (lastLine !== undefined) {
            queryParameters['lastLine'] = lastLine;
        }

        if (areaName1 !== undefined) {
            queryParameters['areaName1'] = areaName1;
        }

        if (areaName2 !== undefined) {
            queryParameters['areaName2'] = areaName2;
        }

        if (areaName3 !== undefined) {
            queryParameters['areaName3'] = areaName3;
        }

        if (areaName4 !== undefined) {
            queryParameters['areaName4'] = areaName4;
        }

        if (postalCode !== undefined) {
            queryParameters['postalCode'] = postalCode;
        }

        if (matchMode !== undefined) {
            queryParameters['matchMode'] = matchMode;
        }

        if (fallbackGeo !== undefined) {
            queryParameters['fallbackGeo'] = fallbackGeo;
        }

        if (fallbackPostal !== undefined) {
            queryParameters['fallbackPostal'] = fallbackPostal;
        }

        if (maxCands !== undefined) {
            queryParameters['maxCands'] = maxCands;
        }

        if (streetOffset !== undefined) {
            queryParameters['streetOffset'] = streetOffset;
        }

        if (streetOffsetUnits !== undefined) {
            queryParameters['streetOffsetUnits'] = streetOffsetUnits;
        }

        if (cornerOffset !== undefined) {
            queryParameters['cornerOffset'] = cornerOffset;
        }

        if (cornerOffsetUnits !== undefined) {
            queryParameters['cornerOffsetUnits'] = cornerOffsetUnits;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: GeocodeServiceResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Gets Geocode
     * Gets Geocode
     * @param body Geocode Request Object
     * @param datapackBundle value of datapackBundle
     */
    public geocodeBatch (body: GeocodeRequest, datapackBundle: string) : Promise<{ response: http.IncomingMessage; body: GeocodeServiceResponseList;  }> {
        const localVarPath = this.basePath + '/geocode-service/v1/transient/{datapackBundle}/geocode'
            .replace('{' + 'datapackBundle' + '}', String(datapackBundle));
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter body was null or undefined when calling geocodeBatch."}]}})
        }

        // verify required parameter 'datapackBundle' is not null or undefined
        if (datapackBundle === null || datapackBundle === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter datapackBundle was null or undefined when calling geocodeBatch."}]}})
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: GeocodeServiceResponseList;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Gets Capabilities
     * Gets Capabilities
     * @param datapackBundle value of datapackBundle
     * @param operation Geocode or ReverseGeocode Operation.
     * @param country Country name or ISO code.
     */
    public getCapabilities (datapackBundle: string, operation?: string, country?: string) : Promise<{ response: http.IncomingMessage; body: GeocodeCapabilitiesResponse;  }> {
        const localVarPath = this.basePath + '/geocode-service/v1/transient/{datapackBundle}/capabilities'
            .replace('{' + 'datapackBundle' + '}', String(datapackBundle));
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'datapackBundle' is not null or undefined
        if (datapackBundle === null || datapackBundle === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter datapackBundle was null or undefined when calling getCapabilities."}]}})
        }

        if (operation !== undefined) {
            queryParameters['operation'] = operation;
        }

        if (country !== undefined) {
            queryParameters['country'] = country;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: GeocodeCapabilitiesResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Gets installed Dictionaries
     * Gets installed Dictionaries
     * @param datapackBundle value of datapackBundle
     * @param country Three Letter ISO Country code
     */
    public getDictionaries (datapackBundle: string, country?: string) : Promise<{ response: http.IncomingMessage; body: ConfiguredDictionaryResponse;  }> {
        const localVarPath = this.basePath + '/geocode-service/v1/transient/{datapackBundle}/dictionaries'
            .replace('{' + 'datapackBundle' + '}', String(datapackBundle));
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'datapackBundle' is not null or undefined
        if (datapackBundle === null || datapackBundle === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter datapackBundle was null or undefined when calling getDictionaries."}]}})
        }

        if (country !== undefined) {
            queryParameters['country'] = country;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: ConfiguredDictionaryResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Gets PBKey
     * Gets PBKey for an input free form address text
     * @param address free form address text
     */
    public getPBKey (address: string) : Promise<{ response: http.IncomingMessage; body: PBKeyResponse;  }> {
        const localVarPath = this.basePath + '/geocode-service/v1/key/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter address was null or undefined when calling getPBKey."}]}})
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: PBKeyResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * Gets PBKeys
     * Gets PBKeys for multiple input addresses
     * @param body 
     */
    public getPBKeys (body: PBKeyAddressRequest) : Promise<{ response: http.IncomingMessage; body: PBKeyResponseList;  }> {
        const localVarPath = this.basePath + '/geocode-service/v1/key/byaddress';
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter body was null or undefined when calling getPBKeys."}]}})
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: PBKeyResponseList;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * reverse Geocode
     * reverse Geocode
     * @param datapackBundle value of datapackBundle
     * @param body Request for Reverse Geocode
     */
    public reverseGeocodBatch (datapackBundle: string, body?: ReverseGeocodeRequest) : Promise<{ response: http.IncomingMessage; body: GeocodeServiceResponseList;  }> {
        const localVarPath = this.basePath + '/geocode-service/v1/transient/{datapackBundle}/reverseGeocode'
            .replace('{' + 'datapackBundle' + '}', String(datapackBundle));
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'datapackBundle' is not null or undefined
        if (datapackBundle === null || datapackBundle === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter datapackBundle was null or undefined when calling reverseGeocodBatch."}]}})
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: GeocodeServiceResponseList;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
    /**
     * reverse Geocode
     * reverse Geocode
     * @param datapackBundle value of datapackBundle
     * @param x Longitude of the location.
     * @param y Latitude of the location.
     * @param country Country name or ISO code.
     * @param coordSysName Coordinate system to convert geometry to in format codespace:code.
     * @param distance Radius in which search is performed.
     * @param distanceUnits Unit of measurement.
     */
    public reverseGeocode (datapackBundle: string, x: number, y: number, country?: string, coordSysName?: string, distance?: number, distanceUnits?: string) : Promise<{ response: http.IncomingMessage; body: GeocodeServiceResponse;  }> {
        const localVarPath = this.basePath + '/geocode-service/v1/transient/{datapackBundle}/reverseGeocode'
            .replace('{' + 'datapackBundle' + '}', String(datapackBundle));
        let queryParameters: any = {};
        let headerParams: any =  this.defaultHeaders;
        let formParams: any = {};


        // verify required parameter 'datapackBundle' is not null or undefined
        if (datapackBundle === null || datapackBundle === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter datapackBundle was null or undefined when calling reverseGeocode."}]}})
        }

        // verify required parameter 'x' is not null or undefined
        if (x === null || x === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter x was null or undefined when calling reverseGeocode."}]}})
        }

        // verify required parameter 'y' is not null or undefined
        if (y === null || y === undefined) {
             return Promise.reject({ response: null, body: {errors:[{"errorCode":"Validation_Error",errorDescription:"Required parameter y was null or undefined when calling reverseGeocode."}]}})
        }

        if (x !== undefined) {
            queryParameters['x'] = x;
        }

        if (y !== undefined) {
            queryParameters['y'] = y;
        }

        if (country !== undefined) {
            queryParameters['country'] = country;
        }

        if (coordSysName !== undefined) {
            queryParameters['coordSysName'] = coordSysName;
        }

        if (distance !== undefined) {
            queryParameters['distance'] = distance;
        }

        if (distanceUnits !== undefined) {
            queryParameters['distanceUnits'] = distanceUnits;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };


   //return this.authentications.oAuth2Password.applyToRequest()
    //.then((data)=>{


       // this.authentications.default.applyToRequest(requestOptions);
        requestOptions.headers = {"authorization":"Bearer " + this.oAuthCred.access_token};
        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return new Promise<{ response: http.IncomingMessage; body: GeocodeServiceResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject(response);
                    }
                }
            });
        });


   /* })
    .catch((error) =>{
    return Promise.reject(error);
    });*/
    }
}
